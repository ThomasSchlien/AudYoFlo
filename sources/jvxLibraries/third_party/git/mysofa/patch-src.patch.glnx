diff -ur libmysofa.orig/src/CMakeLists.txt libmysofa/src/CMakeLists.txt
--- libmysofa.orig/src/CMakeLists.txt	2023-02-03 11:03:54.965008894 +0100
+++ libmysofa/src/CMakeLists.txt	2023-02-01 16:56:18.645532053 +0100
@@ -10,8 +10,8 @@
 
 use_c99()
 
-configure_file(config.h.in config.h)
-include_directories(${CMAKE_CURRENT_BINARY_DIR})
+set(CMAKE_C_FLAGS "-fPIC ${CMAKE_C_FLAGS}")
+configure_file(config.h.in ${PROJECT_SOURCE_DIR}/src/config.h)
 
 if(NOT MSVC)
   if(NOT WIN32)
@@ -51,8 +51,26 @@
   else()
     execute_process(COMMAND ${NUGET} install zlib)
   endif()
-  include_directories(
-    ${PROJECT_SOURCE_DIR}/windows/third-party/zlib-1.2.11/include/)
+
+  # The zlib for MSVC is not part of the project. However, you can get 
+  # pre-compiled libs here: https://www.bruot.org/hp/libraries/
+  # 64 bit version
+  if(JVX_SYSTEM_TOKEN MATCHES "JVX_SYS_WINDOWS_MSVC_64BIT")
+    include_directories(
+        ${PROJECT_SOURCE_DIR}/windows/third-party/zlib/msvc2017_64/include/zlib)
+        # ${PROJECT_SOURCE_DIR}/windows/third-party/zlib-1.2.11/include/)
+
+    set(ZLIB_LIBRARIES ${PROJECT_SOURCE_DIR}/windows/third-party/zlib/msvc2017_64/lib/zlib/zlib.lib)
+  elseif(JVX_SYSTEM_TOKEN MATCHES "JVX_SYS_WINDOWS_MSVC_32BIT")
+    include_directories(
+        ${PROJECT_SOURCE_DIR}/windows/third-party/zlib/msvc2017_32/include/zlib)
+        # ${PROJECT_SOURCE_DIR}/windows/third-party/zlib-1.2.11/include/)
+
+    set(ZLIB_LIBRARIES ${PROJECT_SOURCE_DIR}/windows/third-party/zlib/msvc2017_32/lib/zlib/zlib.lib)
+  else()
+    message(FATAL_ERROR "Could not identify the required zlib.")
+  endif()
+
 endif()
 
 set(libsrc
@@ -76,33 +94,35 @@
     hrtf/easy.c
     hrtf/cache.c
     resampler/speex_resampler.c)
-if(BUILD_STATIC_LIBS)
-add_library(mysofa-static STATIC ${libsrc})
-target_link_libraries(mysofa-static LINK_PRIVATE ${MATH} ${ZLIB_LIBRARIES})
-set_target_properties(
-  mysofa-static
-  PROPERTIES OUTPUT_NAME mysofa CLEAN_DIRECT_OUTPUT 1 POSITION_INDEPENDENT_CODE
-                                                      ${BUILD_SHARED_LIBS})
-install(TARGETS mysofa-static ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})
-
-  if(UNIX
-     AND CODE_COVERAGE
-     AND CMAKE_CXX_COMPILER_ID MATCHES "GNU")
-    target_compile_options(mysofa-static PUBLIC -g -O0 -Wall -fprofile-arcs
+if(LIBMYSOFA_BUILD_STATIC_LIBS)
+    add_library(mysofa-static STATIC ${libsrc})
+    target_link_libraries(mysofa-static LINK_PRIVATE ${MATH} ${ZLIB_LIBRARIES})
+    set_target_properties(
+    mysofa-static
+        PROPERTIES OUTPUT_NAME mysofa_static CLEAN_DIRECT_OUTPUT 1 POSITION_INDEPENDENT_CODE
+                                                      $LIBMYSOFA_BUILD_SHARED_LIBS)
+    target_compile_definitions(mysofa-static PRIVATE "MYSOFA_STATIC_DEFINE")
+	set(POSITION_INDEPENDENT_CODE TRUE)
+    install(TARGETS mysofa-static ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})
+
+    if(UNIX
+        AND CODE_COVERAGE
+        AND CMAKE_CXX_COMPILER_ID MATCHES "GNU")
+        target_compile_options(mysofa-static PUBLIC -g -O0 -Wall -fprofile-arcs
                                                 -ftest-coverage)
-    if(CMAKE_VERSION VERSION_GREATER_EQUAL 3.13)
-      target_link_options(mysofa-static PUBLIC --coverage)
-    else()
-      target_link_libraries(mysofa-static LINK_PUBLIC gcov --coverage)
+        if(CMAKE_VERSION VERSION_GREATER_EQUAL 3.13)
+            target_link_options(mysofa-static PUBLIC --coverage)
+        else()
+            target_link_libraries(mysofa-static LINK_PUBLIC gcov --coverage)
+        endif()
     endif()
-  endif()
 endif()
 
-if(BUILD_SHARED_LIBS)
+if(LIBMYSOFA_BUILD_SHARED_LIBS)
   add_library(mysofa-shared SHARED ${libsrc})
   target_link_libraries(mysofa-shared PRIVATE ${MATH} ${ZLIB_LIBRARIES})
   set_target_properties(mysofa-shared
-                        PROPERTIES OUTPUT_NAME mysofa CLEAN_DIRECT_OUTPUT 1)
+                        PROPERTIES OUTPUT_NAME mysofa_shared CLEAN_DIRECT_OUTPUT 1)
   set_property(
     TARGET mysofa-shared
     PROPERTY
@@ -113,7 +133,7 @@
                                              ${CPACK_PACKAGE_VERSION_MAJOR})
   set_property(TARGET mysofa-shared PROPERTY C_VISIBILITY_PRESET hidden)
   generate_export_header(mysofa-shared BASE_NAME mysofa EXPORT_FILE_NAME
-                         mysofa_export.h)
+                         ${PROJECT_SOURCE_DIR}/src/hrtf/mysofa_export.h)
 
   if(UNIX
      AND CODE_COVERAGE
@@ -134,14 +154,14 @@
     LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR})
 else()
   generate_export_header(mysofa-static BASE_NAME mysofa EXPORT_FILE_NAME
-                         mysofa_export.h)
+                         ${PROJECT_SOURCE_DIR}/src/hrtf/mysofa_export.h)
 endif()
 
 install(FILES hrtf/mysofa.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
 
-if(BUILD_TESTS)
+if(LIBMYSOFA_BUILD_TESTS)
   add_executable(mysofa2json tests/sofa2json.c tests/json.c)
-  if(BUILD_STATIC_LIBS)
+  if(LIBMYSOFA_BUILD_STATIC_LIBS)
     target_link_libraries(mysofa2json mysofa-static)
   else()
     target_link_libraries(mysofa2json mysofa-shared)
@@ -151,7 +171,6 @@
     external
     tests/external.c
     tests/check.c
-    tests/check_data.c
     tests/lookup.c
     tests/neighbors.c
     tests/interpolate.c
@@ -162,7 +181,7 @@
     tests/cache.c
     tests/json.c
     tests/user_defined_variable.c)
-  if(BUILD_STATIC_LIBS)
+  if(LIBMYSOFA_BUILD_STATIC_LIBS)
     target_link_libraries(external mysofa-static ${CUNIT_LIBRARIES})
   else()
     target_link_libraries(external mysofa-shared ${CUNIT_LIBRARIES} m)
@@ -180,7 +199,7 @@
     COMMAND internal)
 
   add_executable(multithread tests/multithread.c)
-  if(BUILD_STATIC_LIBS)
+  if(LIBMYSOFA_BUILD_STATIC_LIBS)
     target_link_libraries(multithread mysofa-static pthread)
   else()
     target_link_libraries(multithread mysofa-shared pthread m)
@@ -203,7 +222,7 @@
     RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
     ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
     LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR})
-endif(BUILD_TESTS)
+endif(LIBMYSOFA_BUILD_TESTS)
 
 set(PKG_CONFIG_PRIVATELIBS
     "${PKG_CONFIG_PRIVATELIBS}"
Nur in libmysofa/src/: config.h.
diff -ur libmysofa.orig/src/hdf/btree.c libmysofa/src/hdf/btree.c
--- libmysofa.orig/src/hdf/btree.c	2023-02-03 11:03:54.965008894 +0100
+++ libmysofa/src/hdf/btree.c	2023-02-01 14:20:31.898431059 +0100
@@ -81,19 +81,19 @@
   UNUSED(message_flags);
 
   /* read signature */
-  if (mysofa_read(reader, buf, 4) != 4 || strncmp(buf, "BTLF", 4)) {
+  if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, "BTLF", 4)) {
     mylog("cannot read signature of BTLF\n"); // LCOV_EXCL_LINE
     return MYSOFA_INVALID_FORMAT;             // LCOV_EXCL_LINE
   }
   buf[4] = 0;
-  mylog("%08" PRIX64 " %.4s\n", (uint64_t)mysofa_tell(reader) - 4, buf);
+  mylog("%08" PRIX64 " %.4s\n", (uint64_t)ftell(reader->fhd) - 4, buf);
 
-  if (mysofa_getc(reader) != 0) {
+  if (fgetc(reader->fhd) != 0) {
     mylog("object BTLF must have version 0\n"); // LCOV_EXCL_LINE
     return MYSOFA_INVALID_FORMAT;               // LCOV_EXCL_LINE
   }
 
-  type = (uint8_t)mysofa_getc(reader);
+  type = (uint8_t)fgetc(reader->fhd);
 
   for (i = 0; i < number_of_records; i++) {
 
@@ -117,7 +117,7 @@
       /*heap_id = */
       readValue(reader, 8);
       /*message_flags = */
-      mysofa_getc(reader);
+      fgetc(reader->fhd);
       /*creation_order = */
       readValue(reader, 4);
       /*hash_of_name = */
@@ -128,7 +128,7 @@
       /*heap_id = */
       readValue(reader, 8);
       /*message_flags = */
-      mysofa_getc(reader);
+      fgetc(reader->fhd);
       /*creation_order = */
       readValue(reader, 4);
       break;
@@ -159,25 +159,25 @@
   char buf[5];
 
   /* read signature */
-  if (mysofa_read(reader, buf, 4) != 4 || strncmp(buf, "BTHD", 4)) {
+  if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, "BTHD", 4)) {
     mylog("cannot read signature of BTHD\n");
     return MYSOFA_INVALID_FORMAT;
   }
   buf[4] = 0;
-  mylog("%08" PRIX64 " %.4s\n", (uint64_t)mysofa_tell(reader) - 4, buf);
+  mylog("%08" PRIX64 " %.4s\n", (uint64_t)ftell(reader->fhd) - 4, buf);
 
-  if (mysofa_getc(reader) != 0) {
+  if (fgetc(reader->fhd) != 0) {
     mylog("object BTHD must have version 0\n");
     return MYSOFA_INVALID_FORMAT;
   }
 
-  btree->type = (uint8_t)mysofa_getc(reader);
+  btree->type = (uint8_t)fgetc(reader->fhd);
   btree->node_size = (uint32_t)readValue(reader, 4);
   btree->record_size = (uint16_t)readValue(reader, 2);
   btree->depth = (uint16_t)readValue(reader, 2);
 
-  btree->split_percent = (uint8_t)mysofa_getc(reader);
-  btree->merge_percent = (uint8_t)mysofa_getc(reader);
+  btree->split_percent = (uint8_t)fgetc(reader->fhd);
+  btree->merge_percent = (uint8_t)fgetc(reader->fhd);
   btree->root_node_address =
       (uint64_t)readValue(reader, reader->superblock.size_of_offsets);
   btree->number_of_records = (uint16_t)readValue(reader, 2);
@@ -196,7 +196,7 @@
   memset(btree->records, 0, sizeof(btree->records[0]) * btree->total_number);
 
   /* read records */
-  if (mysofa_seek(reader, btree->root_node_address, SEEK_SET) < 0)
+  if (fseek(reader->fhd, btree->root_node_address, SEEK_SET) < 0)
     return errno;
   return readBTLF(reader, btree, btree->number_of_records, btree->records);
 }
@@ -235,15 +235,15 @@
   }
 
   /* read signature */
-  if (mysofa_read(reader, buf, 4) != 4 || strncmp(buf, "TREE", 4)) {
+  if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, "TREE", 4)) {
     mylog("cannot read signature of TREE\n"); // LCOV_EXCL_LINE
     return MYSOFA_INVALID_FORMAT;             // LCOV_EXCL_LINE
   }
   buf[4] = 0;
-  mylog("%08" PRIX64 " %.4s\n", (uint64_t)mysofa_tell(reader) - 4, buf);
+  mylog("%08" PRIX64 " %.4s\n", (uint64_t)ftell(reader->fhd) - 4, buf);
 
-  node_type = (uint8_t)mysofa_getc(reader);
-  node_level = (uint8_t)mysofa_getc(reader);
+  node_type = (uint8_t)fgetc(reader->fhd);
+  node_level = (uint8_t)fgetc(reader->fhd);
   entries_used = (uint16_t)readValue(reader, 2);
   if (entries_used > 0x1000)
     return MYSOFA_UNSUPPORTED_FORMAT; // LCOV_EXCL_LINE
@@ -297,8 +297,8 @@
       mylog(" data at %" PRIX64 " len %u\n", child_pointer, size_of_chunk);
 
       /* read data */
-      store = mysofa_tell(reader);
-      if (mysofa_seek(reader, child_pointer, SEEK_SET) < 0) {
+      store = ftell(reader->fhd);
+      if (fseek(reader->fhd, child_pointer, SEEK_SET) < 0) {
         free(output); // LCOV_EXCL_LINE
         return errno; // LCOV_EXCL_LINE
       }
@@ -307,7 +307,7 @@
         free(output);            // LCOV_EXCL_LINE
         return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE
       }
-      if (mysofa_read(reader, input, size_of_chunk) != size_of_chunk) {
+      if (fread(input, 1, size_of_chunk, reader->fhd) != size_of_chunk) {
         free(output);                 // LCOV_EXCL_LINE
         free(input);                  // LCOV_EXCL_LINE
         return MYSOFA_INVALID_FORMAT; // LCOV_EXCL_LINE
@@ -371,7 +371,7 @@
         return MYSOFA_INTERNAL_ERROR; // LCOV_EXCL_LINE
       }
 
-      if (mysofa_seek(reader, store, SEEK_SET) < 0) {
+      if (fseek(reader->fhd, store, SEEK_SET) < 0) {
         free(output); // LCOV_EXCL_LINE
         return errno; // LCOV_EXCL_LINE
       }
@@ -379,8 +379,8 @@
   }
 
   free(output);
-  if (mysofa_seek(reader, 4, SEEK_CUR) < 0) /* skip checksum */
-    return errno;                           // LCOV_EXCL_LINE
+  if (fseek(reader->fhd, 4, SEEK_CUR) < 0) /* skip checksum */
+    return errno;                          // LCOV_EXCL_LINE
 
   return MYSOFA_OK;
 }
diff -ur libmysofa.orig/src/hdf/dataobject.c libmysofa/src/hdf/dataobject.c
--- libmysofa.orig/src/hdf/dataobject.c	2023-02-03 11:03:54.965008894 +0100
+++ libmysofa/src/hdf/dataobject.c	2023-02-01 14:20:31.898431059 +0100
@@ -45,7 +45,7 @@
 
 static int readOHDRHeaderMessageNIL(struct READER *reader, int length) {
 
-  if (mysofa_seek(reader, length, SEEK_CUR) < 0)
+  if (fseek(reader->fhd, length, SEEK_CUR) < 0)
     return errno; // LCOV_EXCL_LINE
 
   return MYSOFA_OK;
@@ -99,7 +99,7 @@
 
   int i;
 
-  ds->type = (uint8_t)mysofa_getc(reader);
+  ds->type = (uint8_t)fgetc(reader->fhd);
 
   for (i = 0; i < ds->dimensionality; i++) {
     if (i < 4) {
@@ -126,15 +126,15 @@
 static int readOHDRHeaderMessageDataspace(struct READER *reader,
                                           struct DATASPACE *ds) {
 
-  int version = mysofa_getc(reader);
+  int version = fgetc(reader->fhd);
 
-  ds->dimensionality = (uint8_t)mysofa_getc(reader);
+  ds->dimensionality = (uint8_t)fgetc(reader->fhd);
   if (ds->dimensionality > 4) {
     mylog("dimensionality must be lower than 5\n"); // LCOV_EXCL_LINE
     return MYSOFA_INVALID_FORMAT;                   // LCOV_EXCL_LINE
   }
 
-  ds->flags = (uint8_t)mysofa_getc(reader);
+  ds->flags = (uint8_t)fgetc(reader->fhd);
 
   switch (version) {
   case 1:
@@ -145,7 +145,7 @@
     // LCOV_EXCL_START
     mylog("object OHDR dataspace message must have version 1 or 2 but is %X at "
           "%lX\n",
-          version, mysofa_tell(reader) - 1);
+          version, ftell(reader->fhd) - 1);
     return MYSOFA_INVALID_FORMAT;
     // LCOV_EXCL_STOP
   }
@@ -162,13 +162,13 @@
 static int readOHDRHeaderMessageLinkInfo(struct READER *reader,
                                          struct LINKINFO *li) {
 
-  if (mysofa_getc(reader) != 0) {
+  if (fgetc(reader->fhd) != 0) {
     mylog(
         "object OHDR link info message must have version 0\n"); // LCOV_EXCL_LINE
     return MYSOFA_UNSUPPORTED_FORMAT; // LCOV_EXCL_LINE
   }
 
-  li->flags = (uint8_t)mysofa_getc(reader);
+  li->flags = (uint8_t)fgetc(reader->fhd);
 
   if (li->flags & 1)
     li->maximum_creation_index = readValue(reader, 8);
@@ -202,12 +202,12 @@
   char *buffer;
   struct DATATYPE dt2;
 
-  dt->class_and_version = (uint8_t)mysofa_getc(reader);
+  dt->class_and_version = (uint8_t)fgetc(reader->fhd);
   if ((dt->class_and_version & 0xf0) != 0x10 &&
       (dt->class_and_version & 0xf0) != 0x30) {
     // LCOV_EXCL_START
     mylog("object OHDR datatype message must have version 1 not %d at %lX\n",
-          dt->class_and_version >> 4, mysofa_tell(reader) - 1);
+          dt->class_and_version >> 4, ftell(reader->fhd) - 1);
     return MYSOFA_UNSUPPORTED_FORMAT;
     // LCOV_EXCL_STOP
   }
@@ -228,10 +228,10 @@
   case 1: /* float */
     dt->u.f.bit_offset = (uint16_t)readValue(reader, 2);
     dt->u.f.bit_precision = (uint16_t)readValue(reader, 2);
-    dt->u.f.exponent_location = (uint8_t)mysofa_getc(reader);
-    dt->u.f.exponent_size = (uint8_t)mysofa_getc(reader);
-    dt->u.f.mantissa_location = (uint8_t)mysofa_getc(reader);
-    dt->u.f.mantissa_size = (uint8_t)mysofa_getc(reader);
+    dt->u.f.exponent_location = (uint8_t)fgetc(reader->fhd);
+    dt->u.f.exponent_size = (uint8_t)fgetc(reader->fhd);
+    dt->u.f.mantissa_location = (uint8_t)fgetc(reader->fhd);
+    dt->u.f.mantissa_size = (uint8_t)fgetc(reader->fhd);
     dt->u.f.exponent_bias = (uint32_t)readValue(reader, 4);
 
     mylog("    FLOAT bit %d %d exponent %d %d MANTISSA %d %d OFFSET %d\n",
@@ -267,7 +267,7 @@
         if (!buffer)
           return MYSOFA_NO_MEMORY;
         for (j = 0; j < maxsize - 1; j++) {
-          c = mysofa_getc(reader);
+          c = fgetc(reader->fhd);
           if (c < 0) {
             free(buffer);
             return MYSOFA_READ_ERROR;
@@ -279,7 +279,7 @@
         buffer[j] = 0;
 
         for (j = 0, c = 0; (dt->size >> (8 * j)) > 0; j++) {
-          c |= mysofa_getc(reader) << (8 * j);
+          c |= fgetc(reader->fhd) << (8 * j);
         }
 
         mylog("   COMPOUND %s offset %d\n", buffer, c);
@@ -307,29 +307,29 @@
         for (j = 0;; j++) {
           if (j == sizeof(name))
             return MYSOFA_INVALID_FORMAT; // LCOV_EXCL_LINE
-          res = mysofa_getc(reader);
+          res = fgetc(reader->fhd);
           if (res < 0)
             return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE
           name[j] = res;
           if (name[j] == 0)
             break;
         }
-        if (mysofa_seek(reader, (7 - j) & 7, SEEK_CUR))
+        if (fseek(reader->fhd, (7 - j) & 7, SEEK_CUR))
           return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE
 
         c = readValue(reader, 4);
-        int dimension = mysofa_getc(reader);
+        int dimension = fgetc(reader->fhd);
         if (dimension != 0) {
           mylog("COMPOUND v1 with dimension not supported");
           return MYSOFA_INVALID_FORMAT; // LCOV_EXCL_LINE
         }
 
         // ignore the following fields
-        if (mysofa_seek(reader, 3 + 4 + 4 + 4 * 4, SEEK_CUR))
+        if (fseek(reader->fhd, 3 + 4 + 4 + 4 * 4, SEEK_CUR))
           return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE
 
         mylog("  COMPOUND %s %d %d %lX\n", name, c, dimension,
-              mysofa_tell(reader));
+              ftell(reader->fhd));
         err = readOHDRHeaderMessageDatatype(reader, &dt2);
         if (err)
           return err; // LCOV_EXCL_LINE
@@ -374,9 +374,9 @@
 
 static int readOHDRHeaderMessageDataFill1or2(struct READER *reader) {
 
-  int spaceAllocationTime = mysofa_getc(reader);
-  int fillValueWriteTime = mysofa_getc(reader);
-  int fillValueDefined = mysofa_getc(reader);
+  int spaceAllocationTime = fgetc(reader->fhd);
+  int fillValueWriteTime = fgetc(reader->fhd);
+  int fillValueDefined = fgetc(reader->fhd);
   if (spaceAllocationTime < 0 || fillValueWriteTime < 0 || fillValueDefined < 0)
     return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE
 
@@ -388,7 +388,7 @@
   }
   if (fillValueDefined > 0) {
     uint32_t size = (uint32_t)readValue(reader, 4);
-    if (mysofa_seek(reader, size, SEEK_CUR) < 0)
+    if (fseek(reader->fhd, size, SEEK_CUR) < 0)
       return errno; // LCOV_EXCL_LINE
   }
 
@@ -399,11 +399,11 @@
   uint8_t flags;
   uint32_t size;
 
-  flags = (uint8_t)mysofa_getc(reader);
+  flags = (uint8_t)fgetc(reader->fhd);
 
   if (flags & (1 << 5)) {
     size = (uint32_t)readValue(reader, 4);
-    if (mysofa_seek(reader, size, SEEK_CUR) < 0)
+    if (fseek(reader->fhd, size, SEEK_CUR) < 0)
       return errno; // LCOV_EXCL_LINE
   }
 
@@ -412,7 +412,7 @@
 
 static int readOHDRHeaderMessageDataFill(struct READER *reader) {
 
-  int version = mysofa_getc(reader);
+  int version = fgetc(reader->fhd);
   switch (version) {
   case 1:
   case 2:
@@ -435,7 +435,7 @@
   uint32_t size;
 
   size = (uint32_t)readValue(reader, 4);
-  if (mysofa_seek(reader, size, SEEK_CUR) < 0)
+  if (fseek(reader->fhd, size, SEEK_CUR) < 0)
     return errno; // LCOV_EXCL_LINE
 
   return MYSOFA_OK;
@@ -473,21 +473,21 @@
   UNUSED(dataset_element_size);
   UNUSED(data_size);
 
-  if (mysofa_getc(reader) != 3) {
+  if (fgetc(reader->fhd) != 3) {
     // LCOV_EXCL_START
     mylog("object OHDR message data layout message must have version 3\n");
     return MYSOFA_INVALID_FORMAT;
     // LCOV_EXCL_STOP
   }
 
-  layout_class = (uint8_t)mysofa_getc(reader);
+  layout_class = (uint8_t)fgetc(reader->fhd);
   mylog("data layout %d\n", layout_class);
 
   switch (layout_class) {
 #if 0
 	case 0:
 	data_size = readValue(reader, 2);
-	mysofa_seek(reader, data_size, SEEK_CUR);
+	fseek(reader->fhd, data_size, SEEK_CUR);
 	mylog("TODO 0 SIZE %u\n", data_size);
 	break;
 #endif
@@ -497,8 +497,8 @@
     mylog("CHUNK Contiguous SIZE %" PRIu64 "\n", data_size);
 
     if (validAddress(reader, data_address)) {
-      store = mysofa_tell(reader);
-      if (mysofa_seek(reader, data_address, SEEK_SET) < 0)
+      store = ftell(reader->fhd);
+      if (fseek(reader->fhd, data_address, SEEK_SET) < 0)
         return errno; // LCOV_EXCL_LINE
       if (data->data) {
         free(data->data);
@@ -511,16 +511,16 @@
       if (!data->data)
         return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE
 
-      err = mysofa_read(reader, data->data, data_size);
+      err = fread(data->data, 1, data_size, reader->fhd);
       if (err != data_size)
         return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE
-      if (mysofa_seek(reader, store, SEEK_SET) < 0)
+      if (fseek(reader->fhd, store, SEEK_SET) < 0)
         return errno; // LCOV_EXCL_LINE
     }
     break;
 
   case 2:
-    dimensionality = (uint8_t)mysofa_getc(reader);
+    dimensionality = (uint8_t)fgetc(reader->fhd);
     mylog("dimensionality %d\n", dimensionality);
 
     if (dimensionality < 1 || dimensionality > DATAOBJECT_MAX_DIMENSIONALITY) {
@@ -542,8 +542,8 @@
       size *= data->ds.dimension_size[i];
 
     if (validAddress(reader, data_address) && dimensionality <= 4) {
-      store = mysofa_tell(reader);
-      if (mysofa_seek(reader, data_address, SEEK_SET) < 0)
+      store = ftell(reader->fhd);
+      if (fseek(reader->fhd, data_address, SEEK_SET) < 0)
         return errno; // LCOV_EXCL_LINE
       if (!data->data) {
         if (size > 0x10000000)
@@ -556,7 +556,7 @@
       err = treeRead(reader, data);
       if (err)
         return err; // LCOV_EXCL_LINE
-      if (mysofa_seek(reader, store, SEEK_SET) < 0)
+      if (fseek(reader->fhd, store, SEEK_SET) < 0)
         return errno; // LCOV_EXCL_LINE
     }
     break;
@@ -583,14 +583,14 @@
 static int readOHDRHeaderMessageGroupInfo(struct READER *reader,
                                           struct GROUPINFO *gi) {
 
-  if (mysofa_getc(reader) != 0) {
+  if (fgetc(reader->fhd) != 0) {
     // LCOV_EXCL_START
     mylog("object OHDR group info message must have version 0\n");
     return MYSOFA_UNSUPPORTED_FORMAT;
     // LCOV_EXCL_STOP
   }
 
-  gi->flags = (uint8_t)mysofa_getc(reader);
+  gi->flags = (uint8_t)fgetc(reader->fhd);
 
   if (gi->flags & 1) {
     gi->maximum_compact_value = (uint16_t)readValue(reader, 2);
@@ -640,7 +640,7 @@
       // LCOV_EXCL_START
       mylog("object OHDR filter pipeline message contains unsupported filter: "
             "%d %lX\n",
-            filter_identification_value, mysofa_tell(reader) - 2);
+            filter_identification_value, ftell(reader->fhd) - 2);
       return MYSOFA_INVALID_FORMAT;
       // LCOV_EXCL_STOP
     }
@@ -649,7 +649,7 @@
     number_client_data_values = (uint16_t)readValue(reader, 2);
 
     if (namelength > 0)
-      if (mysofa_seek(reader, ((namelength - 1) & ~7) + 8, SEEK_CUR) ==
+      if (fseek(reader->fhd, ((namelength - 1) & ~7) + 8, SEEK_CUR) ==
           -1)                     // skip name
         return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE
 
@@ -716,8 +716,8 @@
 static int readOHDRHeaderMessageFilterPipeline(struct READER *reader) {
   int filterversion, filters;
 
-  filterversion = mysofa_getc(reader);
-  filters = mysofa_getc(reader);
+  filterversion = fgetc(reader->fhd);
+  filters = fgetc(reader->fhd);
 
   if (filterversion < 0 || filters < 0)
     return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE
@@ -761,15 +761,15 @@
       gcol = readValue(reader, dt->list - dt->size);
     }
     mylog("    GCOL %d %8" PRIX64 " %8lX\n", dt->list - dt->size, gcol,
-          mysofa_tell(reader));
-    /*	 mysofa_seek(reader, dt->list - dt->size, SEEK_CUR); TODO:
+          ftell(reader->fhd));
+    /*		fseek(reader->fhd, dt->list - dt->size, SEEK_CUR); TODO:
      * TODO: missing part in specification */
   }
 
   switch (dt->class_and_version & 0xf) {
   case 0:
-    mylog("FIXED POINT todo %lX %d\n", mysofa_tell(reader), dt->size);
-    if (mysofa_seek(reader, dt->size, SEEK_CUR))
+    mylog("FIXED POINT todo %lX %d\n", ftell(reader->fhd), dt->size);
+    if (fseek(reader->fhd, dt->size, SEEK_CUR))
       return errno; // LCOV_EXCL_LINE
     break;
 
@@ -778,7 +778,7 @@
     if (buffer == NULL) {
       return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE
     }
-    if (mysofa_read(reader, buffer, dt->size) != dt->size) {
+    if (fread(buffer, 1, dt->size, reader->fhd) != dt->size) {
       free(buffer);             // LCOV_EXCL_LINE
       return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE
     }
@@ -793,8 +793,8 @@
      */
   case 6:
     /* TODO unclear spec */
-    mylog("COMPONENT todo %lX %d\n", mysofa_tell(reader), dt->size);
-    if (mysofa_seek(reader, dt->size, SEEK_CUR))
+    mylog("COMPONENT todo %lX %d\n", ftell(reader->fhd), dt->size);
+    if (fseek(reader->fhd, dt->size, SEEK_CUR))
       return errno; // LCOV_EXCL_LINE
     break;
 
@@ -894,9 +894,9 @@
   } else
     reader->recursive_counter++;
 
-  store = mysofa_tell(reader);
+  store = ftell(reader->fhd);
 
-  if (mysofa_seek(reader, offset, SEEK_SET) < 0)
+  if (fseek(reader->fhd, offset, SEEK_SET) < 0)
     return errno; // LCOV_EXCL_LINE
 
   err = readOCHK(reader, dataobject, offset + length);
@@ -905,7 +905,7 @@
 
   if (store < 0)
     return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE
-  if (mysofa_seek(reader, store, SEEK_SET) < 0)
+  if (fseek(reader->fhd, store, SEEK_SET) < 0)
     return errno; // LCOV_EXCL_LINE
 
   mylog(" continue back\n");
@@ -933,7 +933,7 @@
 
   memset(&d, 0, sizeof(d));
 
-  int version = mysofa_getc(reader);
+  int version = fgetc(reader->fhd);
 
   if (version != 1 && version != 3) {
     // LCOV_EXCL_START
@@ -942,31 +942,31 @@
     // LCOV_EXCL_STOP
   }
 
-  flags = (uint8_t)mysofa_getc(reader);
+  flags = (uint8_t)fgetc(reader->fhd);
 
   name_size = (uint16_t)readValue(reader, 2);
   datatype_size = (uint16_t)readValue(reader, 2);
   dataspace_size = (uint16_t)readValue(reader, 2);
   if (version == 3)
-    encoding = (uint8_t)mysofa_getc(reader);
+    encoding = (uint8_t)fgetc(reader->fhd);
 
   if (name_size > 0x1000)
     return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE
   name = malloc(name_size + 1);
   if (!name)
     return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE
-  if (mysofa_read(reader, name, name_size) != name_size) {
+  if (fread(name, 1, name_size, reader->fhd) != name_size) {
     free(name);   // LCOV_EXCL_LINE
     return errno; // LCOV_EXCL_LINE
   }
-  if (version == 1 && mysofa_seek(reader, (8 - name_size) & 7, SEEK_CUR) != 0) {
+  if (version == 1 && fseek(reader->fhd, (8 - name_size) & 7, SEEK_CUR) != 0) {
     free(name);   // LCOV_EXCL_LINE
     return errno; // LCOV_EXCL_LINE
   }
 
   name[name_size] = 0;
   mylog("  attribute name %s %d %d %lX\n", name, datatype_size, dataspace_size,
-        mysofa_tell(reader));
+        ftell(reader->fhd));
 
   if (version == 3 && (flags & 3)) {
     // LCOV_EXCL_START
@@ -984,7 +984,7 @@
     // LCOV_EXCL_STOP
   }
   if (version == 1) {
-    if (mysofa_seek(reader, (8 - datatype_size) & 7, SEEK_CUR) < 0) {
+    if (fseek(reader->fhd, (8 - datatype_size) & 7, SEEK_CUR) < 0) {
       // LCOV_EXCL_START
       free(name);
       return errno;
@@ -1001,7 +1001,7 @@
     // LCOV_EXCL_STOP
   }
   if (version == 1) {
-    if (mysofa_seek(reader, (8 - dataspace_size) & 7, SEEK_CUR) < 0) {
+    if (fseek(reader->fhd, (8 - dataspace_size) & 7, SEEK_CUR) < 0) {
       // LCOV_EXCL_START
       free(name);
       return errno;
@@ -1044,12 +1044,12 @@
 static int readOHDRHeaderMessageAttributeInfo(struct READER *reader,
                                               struct ATTRIBUTEINFO *ai) {
 
-  if (mysofa_getc(reader) != 0) {
+  if (fgetc(reader->fhd) != 0) {
     mylog("object OHDR attribute info message must have version 0\n");
     return MYSOFA_UNSUPPORTED_FORMAT;
   }
 
-  ai->flags = (uint8_t)mysofa_getc(reader);
+  ai->flags = (uint8_t)fgetc(reader->fhd);
 
   if (ai->flags & 1)
     ai->maximum_creation_index = readValue(reader, 2);
@@ -1073,14 +1073,15 @@
                             struct DATAOBJECT *dataobject,
                             uint64_t end_of_messages) {
 
+  FILE *fhd = reader->fhd;
   int err;
   long end;
 
-  while (mysofa_tell(reader) <
+  while (ftell(fhd) <
          end_of_messages - 4) { /* final gap may has a size of up to 3 */
-    uint8_t header_message_type = (uint8_t)mysofa_getc(reader);
+    uint8_t header_message_type = (uint8_t)fgetc(fhd);
     uint16_t header_message_size = (uint16_t)readValue(reader, 2);
-    uint8_t header_message_flags = (uint8_t)mysofa_getc(reader);
+    uint8_t header_message_flags = (uint8_t)fgetc(fhd);
     if ((header_message_flags & ~5) != 0) {
       mylog("OHDR unsupported OHDR message flag %02X\n", header_message_flags);
       return MYSOFA_UNSUPPORTED_FORMAT;
@@ -1088,13 +1089,13 @@
 
     if ((dataobject->flags & (1 << 2)) != 0)
       /* ignore header_creation_order */
-      if (mysofa_seek(reader, 2, SEEK_CUR) < 0)
+      if (fseek(reader->fhd, 2, SEEK_CUR) < 0)
         return errno;
 
     mylog(" OHDR message type %2d offset %6lX len %4X\n", header_message_type,
-          mysofa_tell(reader), header_message_size);
+          ftell(fhd), header_message_size);
 
-    end = mysofa_tell(reader) + header_message_size;
+    end = ftell(fhd) + header_message_size;
 
     switch (header_message_type) {
     case 0: /* NIL Message */
@@ -1151,14 +1152,13 @@
       return MYSOFA_UNSUPPORTED_FORMAT;
     }
 
-    if (mysofa_tell(reader) != end) {
-      mylog("OHDR message length mismatch by %ld\n", mysofa_tell(reader) - end);
+    if (ftell(fhd) != end) {
+      mylog("OHDR message length mismatch by %ld\n", ftell(fhd) - end);
       return MYSOFA_INTERNAL_ERROR;
     }
   }
 
-  if (mysofa_seek(reader, end_of_messages + 4, SEEK_SET) <
-      0) /* skip checksum */
+  if (fseek(fhd, end_of_messages + 4, SEEK_SET) < 0) /* skip checksum */
     return errno;
 
   return MYSOFA_OK;
@@ -1170,12 +1170,12 @@
   char buf[5];
 
   /* read signature */
-  if (mysofa_read(reader, buf, 4) != 4 || strncmp(buf, "OCHK", 4)) {
+  if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, "OCHK", 4)) {
     mylog("cannot read signature of OCHK\n");
     return MYSOFA_INVALID_FORMAT;
   }
   buf[4] = 0;
-  mylog("%08" PRIX64 " %.4s\n", (uint64_t)mysofa_tell(reader) - 4, buf);
+  mylog("%08" PRIX64 " %.4s\n", (uint64_t)ftell(reader->fhd) - 4, buf);
 
   err = readOHDRmessages(reader, dataobject, end - 4); /* subtract checksum */
   if (err) {
@@ -1192,26 +1192,26 @@
   char buf[5];
 
   memset(dataobject, 0, sizeof(*dataobject));
-  dataobject->address = mysofa_tell(reader);
+  dataobject->address = ftell(reader->fhd);
   dataobject->name = name;
 
   /* read signature */
-  if (mysofa_read(reader, buf, 4) != 4 || strncmp(buf, "OHDR", 4)) {
+  if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, "OHDR", 4)) {
     mylog("cannot read signature of data object\n");
     return MYSOFA_INVALID_FORMAT;
   }
   buf[4] = 0;
   mylog("%08" PRIX64 " %.4s\n", dataobject->address, buf);
 
-  if (mysofa_getc(reader) != 2) {
+  if (fgetc(reader->fhd) != 2) {
     mylog("object OHDR must have version 2\n");
     return MYSOFA_UNSUPPORTED_FORMAT;
   }
 
-  dataobject->flags = (uint8_t)mysofa_getc(reader);
+  dataobject->flags = (uint8_t)fgetc(reader->fhd);
 
-  if (dataobject->flags & (1 << 5)) {          /* bit 5 indicated time stamps */
-    if (mysofa_seek(reader, 16, SEEK_CUR) < 0) /* skip them */
+  if (dataobject->flags & (1 << 5)) {         /* bit 5 indicated time stamps */
+    if (fseek(reader->fhd, 16, SEEK_CUR) < 0) /* skip them */
       return errno;
   }
 
@@ -1224,7 +1224,7 @@
   if (size_of_chunk > 0x1000000)
     return MYSOFA_UNSUPPORTED_FORMAT;
 
-  end_of_messages = mysofa_tell(reader) + size_of_chunk;
+  end_of_messages = ftell(reader->fhd) + size_of_chunk;
 
   err = readOHDRmessages(reader, dataobject, end_of_messages);
 
@@ -1234,14 +1234,14 @@
 
   if (validAddress(reader, dataobject->ai.attribute_name_btree)) {
     /* not needed
-         mysofa_seek(reader, dataobject->ai.attribute_name_btree, SEEK_SET);
+         fseek(reader->fhd, dataobject->ai.attribute_name_btree, SEEK_SET);
          btreeRead(reader, &dataobject->attributes);
     */
   }
 
   /* parse message attribute info */
   if (validAddress(reader, dataobject->ai.fractal_heap_address)) {
-    if (mysofa_seek(reader, dataobject->ai.fractal_heap_address, SEEK_SET) < 0)
+    if (fseek(reader->fhd, dataobject->ai.fractal_heap_address, SEEK_SET) < 0)
       return errno;
     err = fractalheapRead(reader, dataobject, &dataobject->attributes_heap);
     if (err)
@@ -1250,7 +1250,7 @@
 
   /* parse message link info */
   if (validAddress(reader, dataobject->li.fractal_heap_address)) {
-    mysofa_seek(reader, dataobject->li.fractal_heap_address, SEEK_SET);
+    fseek(reader->fhd, dataobject->li.fractal_heap_address, SEEK_SET);
     err = fractalheapRead(reader, dataobject, &dataobject->objects_heap);
     if (err)
       return err;
@@ -1258,7 +1258,7 @@
 
   if (validAddress(reader, dataobject->li.address_btree_index)) {
     /* not needed
-       mysofa_seek(reader, dataobject->li.address_btree_index, SEEK_SET);
+       fseek(reader->fhd, dataobject->li.address_btree_index, SEEK_SET);
        btreeRead(reader, &dataobject->objects);
      */
   }
diff -ur libmysofa.orig/src/hdf/fractalhead.c libmysofa/src/hdf/fractalhead.c
--- libmysofa.orig/src/hdf/fractalhead.c	2023-02-03 11:03:54.965008894 +0100
+++ libmysofa/src/hdf/fractalhead.c	2023-02-01 14:20:31.898431059 +0100
@@ -40,30 +40,30 @@
     reader->recursive_counter++;
 
   /* read signature */
-  if (mysofa_read(reader, buf, 4) != 4 || strncmp(buf, "FHDB", 4)) {
+  if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, "FHDB", 4)) {
     // LCOV_EXCL_START
     mylog("cannot read signature of fractal heap indirect block\n");
     return MYSOFA_INVALID_FORMAT;
     // LCOV_EXCL_STOP
   }
   buf[4] = 0;
-  mylog("%08" PRIX64 " %.4s stack %d\n", (uint64_t)mysofa_tell(reader) - 4, buf,
+  mylog("%08" PRIX64 " %.4s stack %d\n", (uint64_t)ftell(reader->fhd) - 4, buf,
         reader->recursive_counter);
 
-  if (mysofa_getc(reader) != 0) {
+  if (fgetc(reader->fhd) != 0) {
     mylog("object FHDB must have version 0\n"); // LCOV_EXCL_LINE
     return MYSOFA_UNSUPPORTED_FORMAT;           // LCOV_EXCL_LINE
   }
 
   /* ignore heap_header_address */
-  if (mysofa_seek(reader, reader->superblock.size_of_offsets, SEEK_CUR) < 0)
+  if (fseek(reader->fhd, reader->superblock.size_of_offsets, SEEK_CUR) < 0)
     return errno; // LCOV_EXCL_LINE
 
   size = (fractalheap->maximum_heap_size + 7) / 8;
   block_offset = readValue(reader, size);
 
   if (fractalheap->flags & 2)
-    if (mysofa_seek(reader, 4, SEEK_CUR))
+    if (fseek(reader->fhd, 4, SEEK_CUR))
       return errno; // LCOV_EXCL_LINE
 
   offset_size = ceilf(log2f(fractalheap->maximum_heap_size) / 8);
@@ -107,14 +107,14 @@
 
    */
   do {
-    typeandversion = (uint8_t)mysofa_getc(reader);
+    typeandversion = (uint8_t)fgetc(reader->fhd);
     offset = readValue(reader, offset_size);
     length = readValue(reader, length_size);
     if (offset > 0x10000000 || length > 0x10000000)
       return MYSOFA_UNSUPPORTED_FORMAT; // LCOV_EXCL_LINE
 
     mylog(" %d %4" PRIX64 " %" PRIX64 " %08lX\n", typeandversion, offset,
-          length, mysofa_tell(reader) - 1 - offset_size - length_size);
+          length, ftell(reader->fhd) - 1 - offset_size - length_size);
 
     /* TODO: for the following part, the specification is incomplete */
     if (typeandversion == 3) {
@@ -129,7 +129,7 @@
 
       if (!(name = malloc(length + 1)))
         return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE
-      if (mysofa_read(reader, name, length) != length) {
+      if (fread(name, 1, length, reader->fhd) != length) {
         free(name);               // LCOV_EXCL_LINE
         return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE
       }
@@ -156,7 +156,7 @@
           free(name);              // LCOV_EXCL_LINE
           return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE
         }
-        if (mysofa_read(reader, value, len) != len) {
+        if (fread(value, 1, len, reader->fhd) != len) {
           free(value);              // LCOV_EXCL_LINE
           free(name);               // LCOV_EXCL_LINE
           return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE
@@ -199,7 +199,7 @@
         if (unknown3 != 0x0000)
           return MYSOFA_INVALID_FORMAT;
 
-        len = mysofa_getc(reader);
+        len = fgetc(reader->fhd);
         if (len < 0)
           return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE
         if (len > MAX_NAME_LENGTH)
@@ -207,7 +207,7 @@
 
         if (!(name = malloc(len + 1)))
           return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE
-        if (mysofa_read(reader, name, len) != len) {
+        if (fread(name, 1, len, reader->fhd) != len) {
           free(name);               // LCOV_EXCL_LINE
           return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE
         }
@@ -230,8 +230,8 @@
         dir->next = dataobject->directory;
         dataobject->directory = dir;
 
-        store = mysofa_tell(reader);
-        if (mysofa_seek(reader, heap_header_address, SEEK_SET)) {
+        store = ftell(reader->fhd);
+        if (fseek(reader->fhd, heap_header_address, SEEK_SET)) {
           free(name);   // LCOV_EXCL_LINE
           return errno; // LCOV_EXCL_LINE
         }
@@ -244,7 +244,7 @@
         if (store < 0) {
           return errno; // LCOV_EXCL_LINE
         }
-        if (mysofa_seek(reader, store, SEEK_SET) < 0)
+        if (fseek(reader->fhd, store, SEEK_SET) < 0)
           return errno; // LCOV_EXCL_LINE
         break;
       case 0x00080008:
@@ -318,7 +318,7 @@
           return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE
         len = -1;
         for (int i = 0; i < MAX_NAME_LENGTH; i++) {
-          int c = mysofa_getc(reader);
+          int c = fgetc(reader->fhd);
           if (c < 0 || i == MAX_NAME_LENGTH - 1) {
             free(name);               // LCOV_EXCL_LINE
             return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE
@@ -362,7 +362,7 @@
           free(name);              // LCOV_EXCL_LINE
           return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE
         }
-        if (mysofa_read(reader, value, len) != len) {
+        if (fread(value, 1, len, reader->fhd) != len) {
           free(value);              // LCOV_EXCL_LINE
           free(name);               // LCOV_EXCL_LINE
           return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE
@@ -387,7 +387,7 @@
         // LCOV_EXCL_START
       default:
         mylog("FHDB type 1 unsupported values %08" PRIX64 " %" PRIX64 "\n",
-              unknown2, (uint64_t)mysofa_tell(reader) - 4);
+              unknown2, (uint64_t)ftell(reader->fhd) - 4);
         return MYSOFA_UNSUPPORTED_FORMAT;
         // LCOV_EXCL_STOP
       }
@@ -425,14 +425,14 @@
   UNUSED(filter_mask);
 
   /* read signature */
-  if (mysofa_read(reader, buf, 4) != 4 || strncmp(buf, "FHIB", 4)) {
+  if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, "FHIB", 4)) {
     mylog("cannot read signature of fractal heap indirect block\n");
     return MYSOFA_INVALID_FORMAT;
   }
   buf[4] = 0;
-  mylog("%08" PRIX64 " %.4s\n", (uint64_t)mysofa_tell(reader) - 4, buf);
+  mylog("%08" PRIX64 " %.4s\n", (uint64_t)ftell(reader->fhd) - 4, buf);
 
-  if (mysofa_getc(reader) != 0) {
+  if (fgetc(reader->fhd) != 0) {
     mylog("object FHIB must have version 0\n");
     return MYSOFA_UNSUPPORTED_FORMAT;
   }
@@ -479,15 +479,15 @@
     }
     mylog(">> %d %" PRIX64 " %d\n", k, child_direct_block, size);
     if (validAddress(reader, child_direct_block)) {
-      store = mysofa_tell(reader);
-      if (mysofa_seek(reader, child_direct_block, SEEK_SET) < 0)
+      store = ftell(reader->fhd);
+      if (fseek(reader->fhd, child_direct_block, SEEK_SET) < 0)
         return errno;
       err = directblockRead(reader, dataobject, fractalheap);
       if (err)
         return err;
       if (store < 0)
         return MYSOFA_READ_ERROR;
-      if (mysofa_seek(reader, store, SEEK_SET) < 0)
+      if (fseek(reader->fhd, store, SEEK_SET) < 0)
         return errno;
     }
 
@@ -499,15 +499,15 @@
         readValue(reader, reader->superblock.size_of_offsets);
 
     if (validAddress(reader, child_direct_block)) {
-      store = mysofa_tell(reader);
-      if (mysofa_seek(reader, child_indirect_block, SEEK_SET) < 0)
+      store = ftell(reader->fhd);
+      if (fseek(reader->fhd, child_indirect_block, SEEK_SET) < 0)
         return errno;
       err = indirectblockRead(reader, dataobject, fractalheap, iblock_size * 2);
       if (err)
         return err;
       if (store < 0)
         return MYSOFA_READ_ERROR;
-      if (mysofa_seek(reader, store, SEEK_SET) < 0)
+      if (fseek(reader->fhd, store, SEEK_SET) < 0)
         return errno;
     }
 
@@ -538,14 +538,14 @@
   char buf[5];
 
   /* read signature */
-  if (mysofa_read(reader, buf, 4) != 4 || strncmp(buf, "FRHP", 4)) {
+  if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, "FRHP", 4)) {
     mylog("cannot read signature of fractal heap\n");
     return MYSOFA_UNSUPPORTED_FORMAT;
   }
   buf[4] = 0;
-  mylog("%" PRIX64 " %.4s\n", (uint64_t)mysofa_tell(reader) - 4, buf);
+  mylog("%" PRIX64 " %.4s\n", (uint64_t)ftell(reader->fhd) - 4, buf);
 
-  if (mysofa_getc(reader) != 0) {
+  if (fgetc(reader->fhd) != 0) {
     mylog("object fractal heap must have version 0\n");
     return MYSOFA_UNSUPPORTED_FORMAT;
   }
@@ -554,7 +554,7 @@
   fractalheap->encoded_length = (uint16_t)readValue(reader, 2);
   if (fractalheap->encoded_length > 0x8000)
     return MYSOFA_UNSUPPORTED_FORMAT;
-  fractalheap->flags = (uint8_t)mysofa_getc(reader);
+  fractalheap->flags = (uint8_t)fgetc(reader->fhd);
   fractalheap->maximum_size = (uint32_t)readValue(reader, 4);
 
   fractalheap->next_huge_object_id =
@@ -607,14 +607,13 @@
     if (!fractalheap->filter_information)
       return MYSOFA_NO_MEMORY;
 
-    if (mysofa_read(reader, fractalheap->filter_information,
-                    fractalheap->encoded_length) !=
-        fractalheap->encoded_length) {
+    if (fread(fractalheap->filter_information, 1, fractalheap->encoded_length,
+              reader->fhd) != fractalheap->encoded_length) {
       return MYSOFA_READ_ERROR;
     }
   }
 
-  if (mysofa_seek(reader, 4, SEEK_CUR) < 0) { /* skip checksum */
+  if (fseek(reader->fhd, 4, SEEK_CUR) < 0) { /* skip checksum */
     return MYSOFA_READ_ERROR;
   }
 
@@ -630,7 +629,7 @@
 
   if (validAddress(reader, fractalheap->address_of_root_block)) {
 
-    if (mysofa_seek(reader, fractalheap->address_of_root_block, SEEK_SET) < 0)
+    if (fseek(reader->fhd, fractalheap->address_of_root_block, SEEK_SET) < 0)
       return errno;
     if (fractalheap->current_row)
       err = indirectblockRead(reader, dataobject, fractalheap,
diff -ur libmysofa.orig/src/hdf/gcol.c libmysofa/src/hdf/gcol.c
--- libmysofa.orig/src/hdf/gcol.c	2023-02-03 11:03:54.965008894 +0100
+++ libmysofa/src/hdf/gcol.c	2023-02-01 14:20:31.898431059 +0100
@@ -23,21 +23,21 @@
   UNUSED(reference_count);
 
   /* read signature */
-  if (mysofa_read(reader, buf, 4) != 4 || strncmp(buf, "GCOL", 4)) {
+  if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, "GCOL", 4)) {
     mylog("cannot read signature of global heap collection\n");
     return MYSOFA_INVALID_FORMAT;
   }
   buf[4] = 0;
 
-  if (mysofa_getc(reader) != 1) {
+  if (fgetc(reader->fhd) != 1) {
     mylog("object GCOL must have version 1\n");
     return MYSOFA_INVALID_FORMAT;
   }
-  if (mysofa_getc(reader) < 0 || mysofa_getc(reader) < 0 ||
-      mysofa_getc(reader) < 0)
+  if (fgetc(reader->fhd) < 0 || fgetc(reader->fhd) < 0 ||
+      fgetc(reader->fhd) < 0)
     return MYSOFA_READ_ERROR;
 
-  address = mysofa_tell(reader);
+  address = ftell(reader->fhd);
   end = address;
   collection_size = readValue(reader, reader->superblock.size_of_lengths);
   if (collection_size > 0x400000000) {
@@ -46,7 +46,7 @@
   }
   end += collection_size - 8;
 
-  while (mysofa_tell(reader) <= end - 8 - reader->superblock.size_of_lengths) {
+  while (ftell(reader->fhd) <= end - 8 - reader->superblock.size_of_lengths) {
 
     gcol = malloc(sizeof(*gcol));
     if (!gcol)
@@ -57,7 +57,7 @@
       break;
     }
     reference_count = readValue(reader, 2);
-    if (mysofa_seek(reader, 4, SEEK_CUR) < 0) {
+    if (fseek(reader->fhd, 4, SEEK_CUR) < 0) {
       free(gcol);
       return errno;
     }
@@ -75,9 +75,9 @@
     reader->gcol = gcol;
   }
 
-  mylog(" END %08lX vs. %08" PRIX64 "\n", mysofa_tell(reader),
+  mylog(" END %08lX vs. %08" PRIX64 "\n", ftell(reader->fhd),
         end); /* bug in the normal hdf5 specification */
-  /*	mysofa_seek(reader, end, SEEK_SET); */
+  /*	fseek(reader->fhd, end, SEEK_SET); */
   return MYSOFA_OK;
 }
 
@@ -90,13 +90,13 @@
     p = p->next;
   }
   if (!p) {
-    pos = mysofa_tell(reader);
-    if (mysofa_seek(reader, gcol, SEEK_SET) < 0)
+    pos = ftell(reader->fhd);
+    if (fseek(reader->fhd, gcol, SEEK_SET) < 0)
       return MYSOFA_READ_ERROR;
     readGCOL(reader);
     if (pos < 0)
       return MYSOFA_READ_ERROR;
-    if (mysofa_seek(reader, pos, SEEK_SET) < 0)
+    if (fseek(reader->fhd, pos, SEEK_SET) < 0)
       return MYSOFA_READ_ERROR;
 
     p = reader->gcol;
diff -ur libmysofa.orig/src/hdf/reader.h libmysofa/src/hdf/reader.h
--- libmysofa.orig/src/hdf/reader.h	2023-02-03 11:03:54.965008894 +0100
+++ libmysofa/src/hdf/reader.h	2023-02-01 14:20:31.898431059 +0100
@@ -170,11 +170,7 @@
 int treeRead(struct READER *reader, struct DATAOBJECT *data);
 
 struct READER {
-  FILE *fhd; //< file handler if file is used
-
-  const char *memory; //< memory buffer if memory shall be used
-  uint64_t memory_pos;
-  uint64_t memory_len;
+  FILE *fhd;
 
   struct DATAOBJECT *all;
 
@@ -191,9 +187,5 @@
 int gunzip(int inlen, char *in, int *outlen, char *out);
 
 char *mysofa_strdup(const char *s);
-int mysofa_read(struct READER *reader, void *buf, size_t n);
-int mysofa_seek(struct READER *reader, long offset, int whence);
-long mysofa_tell(struct READER *reader);
-int mysofa_getc(struct READER *reader);
 
 #endif /* READER_H_ */
diff -ur libmysofa.orig/src/hdf/superblock.c libmysofa/src/hdf/superblock.c
--- libmysofa.orig/src/hdf/superblock.c	2023-02-03 11:03:54.965008894 +0100
+++ libmysofa/src/hdf/superblock.c	2023-02-01 14:20:31.898431059 +0100
@@ -18,9 +18,9 @@
  */
 
 int superblockRead2or3(struct READER *reader, struct SUPERBLOCK *superblock) {
-  superblock->size_of_offsets = (uint8_t)mysofa_getc(reader);
-  superblock->size_of_lengths = (uint8_t)mysofa_getc(reader);
-  if (mysofa_getc(reader) < 0) /* File Consistency Flags */
+  superblock->size_of_offsets = (uint8_t)fgetc(reader->fhd);
+  superblock->size_of_lengths = (uint8_t)fgetc(reader->fhd);
+  if (fgetc(reader->fhd) < 0) /* File Consistency Flags */
     return MYSOFA_READ_ERROR;
 
   if (superblock->size_of_offsets < 2 || superblock->size_of_offsets > 8 ||
@@ -43,10 +43,10 @@
     return MYSOFA_UNSUPPORTED_FORMAT;
   }
 
-  if (mysofa_seek(reader, 0L, SEEK_END))
+  if (fseek(reader->fhd, 0L, SEEK_END))
     return errno;
 
-  if (superblock->end_of_file_address != mysofa_tell(reader)) {
+  if (superblock->end_of_file_address != ftell(reader->fhd)) {
     mylog("file size mismatch\n");
     return MYSOFA_INVALID_FORMAT;
   }
@@ -54,8 +54,8 @@
   /* end of superblock */
 
   /* seek to first object */
-  if (mysofa_seek(reader, superblock->root_group_object_header_address,
-                  SEEK_SET)) {
+  if (fseek(reader->fhd, superblock->root_group_object_header_address,
+            SEEK_SET)) {
     mylog("cannot seek to first object at %" PRId64 "\n",
           superblock->root_group_object_header_address);
     return errno;
@@ -66,25 +66,25 @@
 
 int superblockRead0or1(struct READER *reader, struct SUPERBLOCK *superblock,
                        int version) {
-  if (mysofa_getc(reader) !=
+  if (fgetc(reader->fhd) !=
       0) /* Version Number of the File’s Free Space Information */
     return MYSOFA_INVALID_FORMAT;
 
-  if (mysofa_getc(reader) !=
+  if (fgetc(reader->fhd) !=
       0) /* Version Number of the Root Group Symbol Table Entry */
     return MYSOFA_INVALID_FORMAT;
 
-  if (mysofa_getc(reader) != 0)
+  if (fgetc(reader->fhd) != 0)
     return MYSOFA_INVALID_FORMAT;
 
-  if (mysofa_getc(reader) !=
+  if (fgetc(reader->fhd) !=
       0) /* Version Number of the Shared Header Message Format */
     return MYSOFA_INVALID_FORMAT;
 
-  superblock->size_of_offsets = (uint8_t)mysofa_getc(reader);
-  superblock->size_of_lengths = (uint8_t)mysofa_getc(reader);
+  superblock->size_of_offsets = (uint8_t)fgetc(reader->fhd);
+  superblock->size_of_lengths = (uint8_t)fgetc(reader->fhd);
 
-  if (mysofa_getc(reader) != 0)
+  if (fgetc(reader->fhd) != 0)
     return MYSOFA_INVALID_FORMAT;
 
   if (superblock->size_of_offsets < 2 || superblock->size_of_offsets > 8 ||
@@ -162,17 +162,17 @@
     return MYSOFA_UNSUPPORTED_FORMAT;
   }
 
-  if (mysofa_seek(reader, 0L, SEEK_END))
+  if (fseek(reader->fhd, 0L, SEEK_END))
     return errno;
 
-  if (superblock->end_of_file_address != mysofa_tell(reader)) {
+  if (superblock->end_of_file_address != ftell(reader->fhd)) {
     mylog("file size mismatch\n");
   }
   /* end of superblock */
 
   /* seek to first object */
-  if (mysofa_seek(reader, superblock->root_group_object_header_address,
-                  SEEK_SET)) {
+  if (fseek(reader->fhd, superblock->root_group_object_header_address,
+            SEEK_SET)) {
     mylog("cannot seek to first object at %" PRId64 "\n",
           superblock->root_group_object_header_address);
     return errno;
@@ -186,14 +186,14 @@
   memset(superblock, 0, sizeof(*superblock));
 
   /* signature */
-  if (mysofa_read(reader, buf, 8) != 8 ||
+  if (fread(buf, 1, 8, reader->fhd) != 8 ||
       strncmp("\211HDF\r\n\032\n", buf, 8)) {
     mylog("file does not have correct signature");
     return MYSOFA_INVALID_FORMAT;
   }
 
   /* read version of superblock, must be 0,1,2, or 3 */
-  int version = mysofa_getc(reader);
+  int version = fgetc(reader->fhd);
 
   switch (version) {
   case 0:
diff -ur libmysofa.orig/src/hrtf/cache.c libmysofa/src/hrtf/cache.c
--- libmysofa.orig/src/hrtf/cache.c	2023-02-03 11:03:54.965008894 +0100
+++ libmysofa/src/hrtf/cache.c	2023-02-01 14:20:31.898431059 +0100
@@ -19,7 +19,7 @@
   char *filename;
   float samplerate;
   int count;
-} *cache = NULL;
+} * cache;
 
 static int compare_filenames(const char *a, const char *b) {
   if (a == NULL && b == NULL)
@@ -31,7 +31,7 @@
   return strcmp(a, b);
 }
 
-MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_cache_lookup(const char *filename,
+struct MYSOFA_EASY *mysofa_cache_lookup(const char *filename,
                                                       float samplerate) {
   struct MYSOFA_CACHE_ENTRY *p;
   struct MYSOFA_EASY *res = NULL;
@@ -51,7 +51,7 @@
   return res;
 }
 
-MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_cache_store(struct MYSOFA_EASY *easy,
+struct MYSOFA_EASY *mysofa_cache_store(struct MYSOFA_EASY *easy,
                                                      const char *filename,
                                                      float samplerate) {
   struct MYSOFA_CACHE_ENTRY *p;
@@ -89,7 +89,7 @@
   return easy;
 }
 
-MYSOFA_EXPORT void mysofa_cache_release(struct MYSOFA_EASY *easy) {
+void mysofa_cache_release(struct MYSOFA_EASY *easy) {
   struct MYSOFA_CACHE_ENTRY **p;
   int count;
 
@@ -116,7 +116,7 @@
   }
 }
 
-MYSOFA_EXPORT void mysofa_cache_release_all() {
+void mysofa_cache_release_all() {
   struct MYSOFA_CACHE_ENTRY *p;
 
   p = cache;
diff -ur libmysofa.orig/src/hrtf/check.c libmysofa/src/hrtf/check.c
--- libmysofa.orig/src/hrtf/check.c	2023-02-03 11:03:54.965008894 +0100
+++ libmysofa/src/hrtf/check.c	2023-02-01 14:20:31.898431059 +0100
@@ -7,7 +7,8 @@
 #include <string.h>
 
 static int compareValues(struct MYSOFA_ARRAY *array, const float *compare,
-                         int elements, int size) {
+                         int elements, int size)
+{
   int i, j;
   if (array->values == NULL || array->elements != elements * size)
     return 0;
@@ -22,7 +23,8 @@
 static const float array001[] = {0, 0, 1};
 static const float array100[] = {1, 0, 0};
 
-MYSOFA_EXPORT int mysofa_check(struct MYSOFA_HRTF *hrtf) {
+int mysofa_check(struct MYSOFA_HRTF *hrtf)
+{
 
   /* check for valid parameter ranges */
   /*
@@ -74,24 +76,31 @@
 
   /* verify format */
 
-  if (hrtf->ListenerView.values) {
+  if (hrtf->ListenerView.values)
+  {
     int m = 1;
     if (!verifyAttribute(hrtf->ListenerView.attributes, "DIMENSION_LIST",
-                         "I,C")) {
+                         "I,C"))
+    {
       if (!verifyAttribute(hrtf->ListenerView.attributes, "DIMENSION_LIST",
-                           "M,C")) {
+                           "M,C"))
+      {
         return MYSOFA_INVALID_DIMENSION_LIST; // LCOV_EXCL_LINE
       }
       m = hrtf->M;
     }
-    if (verifyAttribute(hrtf->ListenerView.attributes, "Type", "cartesian")) {
+    if (verifyAttribute(hrtf->ListenerView.attributes, "Type", "cartesian"))
+    {
       if (!compareValues(&hrtf->ListenerView, array100, 3, m))
         return MYSOFA_INVALID_FORMAT; // LCOV_EXCL_LINE
-    } else if (verifyAttribute(hrtf->ListenerView.attributes, "Type",
-                               "spherical")) {
+    }
+    else if (verifyAttribute(hrtf->ListenerView.attributes, "Type",
+                             "spherical"))
+    {
       if (!compareValues(&hrtf->ListenerView, array001, 3, m))
         return MYSOFA_INVALID_FORMAT; // LCOV_EXCL_LINE
-    } else
+    }
+    else
       return MYSOFA_INVALID_COORDINATE_TYPE; // LCOV_EXCL_LINE
   }
 
@@ -118,9 +127,11 @@
 
   int m = 1;
   if (!verifyAttribute(hrtf->EmitterPosition.attributes, "DIMENSION_LIST",
-                       "E,C,I")) {
+                       "E,C,I"))
+  {
     if (!verifyAttribute(hrtf->EmitterPosition.attributes, "DIMENSION_LIST",
-                         "E,C,M")) {
+                         "E,C,M"))
+    {
       return MYSOFA_ONLY_EMITTER_WITH_ECI_SUPPORTED; // LCOV_EXCL_LINE
     }
     m = hrtf->M;
@@ -129,7 +140,8 @@
   if (!compareValues(&hrtf->EmitterPosition, array000, 3, m))
     return MYSOFA_ONLY_EMITTER_WITH_ECI_SUPPORTED; // LCOV_EXCL_LINE
 
-  if (hrtf->DataDelay.values) {
+  if (hrtf->DataDelay.values)
+  {
     if (!verifyAttribute(hrtf->DataDelay.attributes, "DIMENSION_LIST", "I,R") &&
         !verifyAttribute(hrtf->DataDelay.attributes, "DIMENSION_LIST", "M,R"))
       return MYSOFA_ONLY_DELAYS_WITH_IR_OR_MR_SUPPORTED; // LCOV_EXCL_LINE
@@ -142,14 +154,18 @@
     return MYSOFA_ONLY_THE_SAME_SAMPLING_RATE_SUPPORTED; // LCOV_EXCL_LINE
 
   if (verifyAttribute(hrtf->ReceiverPosition.attributes, "DIMENSION_LIST",
-                      "R,C,I")) {
+                      "R,C,I"))
+  {
     // do nothing
-  } else if (verifyAttribute(hrtf->ReceiverPosition.attributes,
-                             "DIMENSION_LIST", "R,C,M")) {
+  }
+  else if (verifyAttribute(hrtf->ReceiverPosition.attributes,
+                           "DIMENSION_LIST", "R,C,M"))
+  {
     if (hrtf->ReceiverPosition.elements != hrtf->C * hrtf->R * hrtf->M)
       return MYSOFA_INVALID_RECEIVER_POSITIONS;
 
-    for (int i = 0; i < hrtf->C * hrtf->R; i++) {
+    for (int i = 0; i < hrtf->C * hrtf->R; i++)
+    {
       int offset = i * hrtf->M;
       double receiverPosition = hrtf->ReceiverPosition.values[offset];
       for (int j = 1; j < hrtf->M; j++)
@@ -157,7 +173,9 @@
                      hrtf->ReceiverPosition.values[offset + j]))
           return MYSOFA_RECEIVERS_WITH_RCI_SUPPORTED; // LCOV_EXCL_LINE
     }
-  } else {
+  }
+  else
+  {
     return MYSOFA_RECEIVERS_WITH_RCI_SUPPORTED; // LCOV_EXCL_LINE
   }
 
@@ -165,17 +183,18 @@
     return MYSOFA_RECEIVERS_WITH_CARTESIAN_SUPPORTED; // LCOV_EXCL_LINE
 
   if (hrtf->ReceiverPosition.elements < hrtf->C * hrtf->R ||
-      fabs(hrtf->ReceiverPosition.values[0]) >= 0.02f || // we assumes a somehow symetrical face
-      fabs(hrtf->ReceiverPosition.values[2]) >= 0.02f ||
-      fabs(hrtf->ReceiverPosition.values[3]) >= 0.02f ||
-      fabs(hrtf->ReceiverPosition.values[5]) >= 0.02f)
+      !fequals(hrtf->ReceiverPosition.values[0], 0.f) ||
+      !fequals(hrtf->ReceiverPosition.values[2], 0.f) ||
+      !fequals(hrtf->ReceiverPosition.values[3], 0.f) ||
+      !fequals(hrtf->ReceiverPosition.values[5], 0.f))
   {
     return MYSOFA_INVALID_RECEIVER_POSITIONS; // LCOV_EXCL_LINE
   }
-  if (fabs(hrtf->ReceiverPosition.values[4] +
-           hrtf->ReceiverPosition.values[1]) >= 0.02f)
+  if (!fequals(hrtf->ReceiverPosition.values[4],
+               -hrtf->ReceiverPosition.values[1]))
     return MYSOFA_INVALID_RECEIVER_POSITIONS; // LCOV_EXCL_LINE
-  if (hrtf->ReceiverPosition.values[1] < 0) {
+  if (hrtf->ReceiverPosition.values[1] < 0)
+  {
     if (!verifyAttribute(hrtf->attributes, "APIName",
                          "ARI SOFA API for Matlab/Octave"))
       return MYSOFA_INVALID_RECEIVER_POSITIONS; // LCOV_EXCL_LINE
diff -ur libmysofa.orig/src/hrtf/easy.c libmysofa/src/hrtf/easy.c
--- libmysofa.orig/src/hrtf/easy.c	2023-02-03 11:03:54.965008894 +0100
+++ libmysofa/src/hrtf/easy.c	2023-02-01 14:20:31.902431210 +0100
@@ -14,41 +14,51 @@
 #include "mysofa.h"
 #include "mysofa_export.h"
 
-static struct MYSOFA_EASY *easy_processing(struct MYSOFA_HRTF *hrtf,
-                                           float samplerate, int *filterlength,
-                                           int *err, bool applyNorm,
-                                           float neighbor_angle_step,
-                                           float neighbor_radius_step) {
-  if (!hrtf)
-    return NULL;
+/**
+ *
+ */
+
+static struct MYSOFA_EASY *
+mysofa_open_default(const char *filename, float samplerate, int *filterlength,
+                    int *err, bool applyNorm, float neighbor_angle_step,
+                    float neighbor_radius_step)
+{
 
-  struct MYSOFA_EASY *easy =
-      (struct MYSOFA_EASY *)malloc(sizeof(struct MYSOFA_EASY));
+  struct MYSOFA_EASY *easy = malloc(sizeof(struct MYSOFA_EASY));
 
-  if (!easy) {
+  if (!easy)
+  {
     *err = MYSOFA_NO_MEMORY;
-    mysofa_free(hrtf);
     return NULL;
   }
 
   // set all values of struct to their default "0" (to avoid freeing unallocated
   // values in mysofa_free)
   *easy = (struct MYSOFA_EASY){0};
-  easy->hrtf = hrtf;
+
+  easy->hrtf = mysofa_load(filename, err);
+  if (!easy->hrtf)
+  {
+    mysofa_close(easy);
+    return NULL;
+  }
 
   *err = mysofa_check(easy->hrtf);
-  if (*err != MYSOFA_OK) {
+  if (*err != MYSOFA_OK)
+  {
     mysofa_close(easy);
     return NULL;
   }
 
   *err = mysofa_resample(easy->hrtf, samplerate);
-  if (*err != MYSOFA_OK) {
+  if (*err != MYSOFA_OK)
+  {
     mysofa_close(easy);
     return NULL;
   }
 
-  if (applyNorm) {
+  if (applyNorm)
+  {
     mysofa_loudness(easy->hrtf);
   }
 
@@ -58,14 +68,16 @@
 
   mysofa_tocartesian(easy->hrtf);
 
-  if (easy->hrtf->SourcePosition.elements != easy->hrtf->C * easy->hrtf->M) {
+  if (easy->hrtf->SourcePosition.elements != easy->hrtf->C * easy->hrtf->M)
+  {
     *err = MYSOFA_INVALID_FORMAT;
     mysofa_close(easy);
     return NULL;
   }
 
   easy->lookup = mysofa_lookup_init(easy->hrtf);
-  if (easy->lookup == NULL) {
+  if (easy->lookup == NULL)
+  {
     *err = MYSOFA_INTERNAL_ERROR;
     mysofa_close(easy);
     return NULL;
@@ -76,83 +88,64 @@
 
   *filterlength = easy->hrtf->N;
 
-  easy->fir = (float *)malloc(easy->hrtf->N * easy->hrtf->R * sizeof(float));
+  easy->fir = malloc(easy->hrtf->N * easy->hrtf->R * sizeof(float));
   assert(easy->fir);
 
   return easy;
 }
 
-MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_open(const char *filename,
+struct MYSOFA_EASY *mysofa_open(const char *filename,
                                               float samplerate,
-                                              int *filterlength, int *err) {
-  return easy_processing(mysofa_load(filename, err), samplerate, filterlength,
-                         err, true, MYSOFA_DEFAULT_NEIGH_STEP_ANGLE,
-                         MYSOFA_DEFAULT_NEIGH_STEP_RADIUS);
+                                              int *filterlength, int *err)
+{
+  return mysofa_open_default(filename, samplerate, filterlength, err, true,
+                             MYSOFA_DEFAULT_NEIGH_STEP_ANGLE,
+                             MYSOFA_DEFAULT_NEIGH_STEP_RADIUS);
 }
 
-MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_open_no_norm(const char *filename,
+struct MYSOFA_EASY *mysofa_open_no_norm(const char *filename,
                                                       float samplerate,
                                                       int *filterlength,
-                                                      int *err) {
-  return easy_processing(mysofa_load(filename, err), samplerate, filterlength,
-                         err, false, MYSOFA_DEFAULT_NEIGH_STEP_ANGLE,
-                         MYSOFA_DEFAULT_NEIGH_STEP_RADIUS);
+                                                      int *err)
+{
+  return mysofa_open_default(filename, samplerate, filterlength, err, false,
+                             MYSOFA_DEFAULT_NEIGH_STEP_ANGLE,
+                             MYSOFA_DEFAULT_NEIGH_STEP_RADIUS);
 }
 
-MYSOFA_EXPORT struct MYSOFA_EASY *
+struct MYSOFA_EASY *
 mysofa_open_advanced(const char *filename, float samplerate, int *filterlength,
                      int *err, bool norm, float neighbor_angle_step,
-                     float neighbor_radius_step) {
-  return easy_processing(mysofa_load(filename, err), samplerate, filterlength,
-                         err, norm, neighbor_angle_step, neighbor_radius_step);
-}
-
-MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_open_data(const char *data, long size,
-                                                   float samplerate,
-                                                   int *filterlength,
-                                                   int *err) {
-  return easy_processing(
-      mysofa_load_data(data, size, err), samplerate, filterlength, err, true,
-      MYSOFA_DEFAULT_NEIGH_STEP_ANGLE, MYSOFA_DEFAULT_NEIGH_STEP_RADIUS);
-}
-
-MYSOFA_EXPORT struct MYSOFA_EASY *
-mysofa_open_data_no_norm(const char *data, long size, float samplerate,
-                         int *filterlength, int *err) {
-  return easy_processing(
-      mysofa_load_data(data, size, err), samplerate, filterlength, err, false,
-      MYSOFA_DEFAULT_NEIGH_STEP_ANGLE, MYSOFA_DEFAULT_NEIGH_STEP_RADIUS);
-}
-
-MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_open_data_advanced(
-    const char *data, long size, float samplerate, int *filterlength, int *err,
-    bool norm, float neighbor_angle_step, float neighbor_radius_step) {
-  return easy_processing(mysofa_load_data(data, size, err), samplerate,
-                         filterlength, err, norm, neighbor_angle_step,
-                         neighbor_radius_step);
+                     float neighbor_radius_step)
+{
+  return mysofa_open_default(filename, samplerate, filterlength, err, norm,
+                             neighbor_angle_step, neighbor_radius_step);
 }
 
-MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_open_cached(const char *filename,
+struct MYSOFA_EASY *mysofa_open_cached(const char *filename,
                                                      float samplerate,
                                                      int *filterlength,
-                                                     int *err) {
+                                                     int *err)
+{
   struct MYSOFA_EASY *res = mysofa_cache_lookup(filename, samplerate);
-  if (res) {
+  if (res)
+  {
     *filterlength = res->hrtf->N;
-    *err = MYSOFA_OK;
     return res;
   }
   res = mysofa_open(filename, samplerate, filterlength, err);
-  if (res) {
+  if (res)
+  {
     res = mysofa_cache_store(res, filename, samplerate);
   }
   return res;
 }
 
-MYSOFA_EXPORT void mysofa_getfilter_short(struct MYSOFA_EASY *easy, float x,
+void mysofa_getfilter_short(struct MYSOFA_EASY *easy, float x,
                                           float y, float z, short *IRleft,
                                           short *IRright, int *delayLeft,
-                                          int *delayRight) {
+                                          int *delayRight)
+{
   float c[3];
   float delays[2];
   float *fl;
@@ -175,15 +168,17 @@
 
   fl = easy->fir;
   fr = easy->fir + easy->hrtf->N;
-  for (i = easy->hrtf->N; i > 0; i--) {
+  for (i = easy->hrtf->N; i > 0; i--)
+  {
     *IRleft++ = (short)(*fl++ * 32767.);
     *IRright++ = (short)(*fr++ * 32767.);
   }
 }
 
-MYSOFA_EXPORT void mysofa_getfilter_float_advanced(
+void mysofa_getfilter_float_advanced(
     struct MYSOFA_EASY *easy, float x, float y, float z, float *IRleft,
-    float *IRright, float *delayLeft, float *delayRight, bool interpolate) {
+    float *IRright, float *delayLeft, float *delayRight, bool interpolate)
+{
   float c[3];
   float delays[2];
   float *fl;
@@ -200,7 +195,8 @@
   neighbors = mysofa_neighborhood(easy->neighborhood, nearest);
 
   // bypass interpolate by forcing current cooordinates to nearest's
-  if (!interpolate) {
+  if (!interpolate)
+  {
     memcpy(c, easy->hrtf->SourcePosition.values + nearest * easy->hrtf->C,
            sizeof(float) * easy->hrtf->C);
   }
@@ -213,30 +209,35 @@
 
   fl = res;
   fr = res + easy->hrtf->N;
-  for (i = easy->hrtf->N; i > 0; i--) {
+  for (i = easy->hrtf->N; i > 0; i--)
+  {
     *IRleft++ = *fl++;
     *IRright++ = *fr++;
   }
 }
 
-MYSOFA_EXPORT void mysofa_getfilter_float(struct MYSOFA_EASY *easy, float x,
+void mysofa_getfilter_float(struct MYSOFA_EASY *easy, float x,
                                           float y, float z, float *IRleft,
                                           float *IRright, float *delayLeft,
-                                          float *delayRight) {
+                                          float *delayRight)
+{
   mysofa_getfilter_float_advanced(easy, x, y, z, IRleft, IRright, delayLeft,
                                   delayRight, true);
 }
 
-MYSOFA_EXPORT void
+void
 mysofa_getfilter_float_nointerp(struct MYSOFA_EASY *easy, float x, float y,
                                 float z, float *IRleft, float *IRright,
-                                float *delayLeft, float *delayRight) {
+                                float *delayLeft, float *delayRight)
+{
   mysofa_getfilter_float_advanced(easy, x, y, z, IRleft, IRright, delayLeft,
                                   delayRight, false);
 }
 
-MYSOFA_EXPORT void mysofa_close(struct MYSOFA_EASY *easy) {
-  if (easy) {
+void mysofa_close(struct MYSOFA_EASY *easy)
+{
+  if (easy)
+  {
     if (easy->fir)
       free(easy->fir);
     if (easy->neighborhood)
@@ -249,6 +250,7 @@
   }
 }
 
-MYSOFA_EXPORT void mysofa_close_cached(struct MYSOFA_EASY *easy) {
+void mysofa_close_cached(struct MYSOFA_EASY *easy)
+{
   mysofa_cache_release(easy);
 }
diff -ur libmysofa.orig/src/hrtf/interpolate.c libmysofa/src/hrtf/interpolate.c
--- libmysofa.orig/src/hrtf/interpolate.c	2023-02-03 11:03:54.965008894 +0100
+++ libmysofa/src/hrtf/interpolate.c	2023-02-01 14:20:31.902431210 +0100
@@ -14,7 +14,7 @@
 
 /* #define VDEBUG */
 
-MYSOFA_EXPORT float *mysofa_interpolate(struct MYSOFA_HRTF *hrtf,
+float *mysofa_interpolate(struct MYSOFA_HRTF *hrtf,
                                         float *cordinate, int nearest,
                                         int *neighborhood, float *fir,
                                         float *delays) {
diff -ur libmysofa.orig/src/hrtf/lookup.c libmysofa/src/hrtf/lookup.c
--- libmysofa.orig/src/hrtf/lookup.c	2023-02-03 11:03:54.965008894 +0100
+++ libmysofa/src/hrtf/lookup.c	2023-02-01 14:20:31.902431210 +0100
@@ -15,8 +15,9 @@
 #include "mysofa_export.h"
 #include "tools.h"
 
-MYSOFA_EXPORT struct MYSOFA_LOOKUP *
-mysofa_lookup_init(struct MYSOFA_HRTF *hrtf) {
+struct MYSOFA_LOOKUP *
+mysofa_lookup_init(struct MYSOFA_HRTF *hrtf)
+{
   int i;
   struct MYSOFA_LOOKUP *lookup;
 
@@ -42,26 +43,33 @@
   lookup->theta_max = FLT_MIN;
   lookup->radius_min = FLT_MAX;
   lookup->radius_max = FLT_MIN;
-  for (i = 0; i < hrtf->M; i++) {
+  for (i = 0; i < hrtf->M; i++)
+  {
     memcpy(origin, hrtf->SourcePosition.values + i * hrtf->C,
            sizeof(float) * hrtf->C);
     convertCartesianToSpherical(origin, hrtf->C);
-    if (origin[0] < lookup->phi_min) {
+    if (origin[0] < lookup->phi_min)
+    {
       lookup->phi_min = origin[0];
     }
-    if (origin[0] > lookup->phi_max) {
+    if (origin[0] > lookup->phi_max)
+    {
       lookup->phi_max = origin[0];
     }
-    if (origin[1] < lookup->theta_min) {
+    if (origin[1] < lookup->theta_min)
+    {
       lookup->theta_min = origin[1];
     }
-    if (origin[1] > lookup->theta_max) {
+    if (origin[1] > lookup->theta_max)
+    {
       lookup->theta_max = origin[1];
     }
-    if (origin[2] < lookup->radius_min) {
+    if (origin[2] < lookup->radius_min)
+    {
       lookup->radius_min = origin[2];
     }
-    if (origin[2] > lookup->radius_max) {
+    if (origin[2] > lookup->radius_max)
+    {
       lookup->radius_max = origin[2];
     }
   }
@@ -71,7 +79,8 @@
    * Allocate kd tree
    */
   lookup->kdtree = kd_create();
-  if (!lookup->kdtree) {
+  if (!lookup->kdtree)
+  {
     free(lookup);
     return NULL;
   }
@@ -79,7 +88,8 @@
   /*
    * add coordinates to the tree
    */
-  for (i = 0; i < hrtf->M; i++) {
+  for (i = 0; i < hrtf->M; i++)
+  {
     float *f = hrtf->SourcePosition.values + i * hrtf->C;
     kd_insert((struct kdtree *)lookup->kdtree, f, (void *)(intptr_t)i);
   }
@@ -92,19 +102,23 @@
  * BE AWARE: The coordinate vector will be normalized if required
  * A return value of -1 = MYSOFA_INTERNAL_ERROR indicates an error
  */
-MYSOFA_EXPORT int mysofa_lookup(struct MYSOFA_LOOKUP *lookup,
-                                float *coordinate) {
+int mysofa_lookup(struct MYSOFA_LOOKUP *lookup,
+                                float *coordinate) 
+{
 
   int index;
   void *res;
   int success;
   float r = radius(coordinate);
-  if (r > lookup->radius_max) {
+  if (r > lookup->radius_max)
+  {
     r = lookup->radius_max / r;
     coordinate[0] *= r;
     coordinate[1] *= r;
     coordinate[2] *= r;
-  } else if (r < lookup->radius_min) {
+  }
+  else if (r < lookup->radius_min)
+  {
     r = lookup->radius_min / r;
     coordinate[0] *= r;
     coordinate[1] *= r;
@@ -112,15 +126,18 @@
   }
 
   success = kd_nearest((struct kdtree *)lookup->kdtree, coordinate, &res);
-  if (success != 0) {
+  if (success != 0)
+  {
     return MYSOFA_INTERNAL_ERROR;
   }
   index = (uintptr_t)res;
   return index;
 }
 
-MYSOFA_EXPORT void mysofa_lookup_free(struct MYSOFA_LOOKUP *lookup) {
-  if (lookup) {
+void mysofa_lookup_free(struct MYSOFA_LOOKUP *lookup)
+{
+  if (lookup)
+  {
     kd_free((struct kdtree *)lookup->kdtree);
     free(lookup);
   }
diff -ur libmysofa.orig/src/hrtf/minphase.c libmysofa/src/hrtf/minphase.c
--- libmysofa.orig/src/hrtf/minphase.c	2023-02-03 11:03:54.965008894 +0100
+++ libmysofa/src/hrtf/minphase.c	2023-02-01 14:20:31.902431210 +0100
@@ -45,7 +45,7 @@
   *end = e + 1;
 }
 
-MYSOFA_EXPORT int mysofa_minphase(struct MYSOFA_HRTF *hrtf, float threshold) {
+int mysofa_minphase(struct MYSOFA_HRTF *hrtf, float threshold) {
   int i;
   int max = 0;
   int filters;
Nur in libmysofa/src/hrtf: mysofa_export.h.
diff -ur libmysofa.orig/src/hrtf/mysofa.h libmysofa/src/hrtf/mysofa.h
--- libmysofa.orig/src/hrtf/mysofa.h	2023-02-03 11:03:54.965008894 +0100
+++ libmysofa/src/hrtf/mysofa.h	2023-02-01 14:20:31.902431210 +0100
@@ -12,7 +12,7 @@
 
 #include <stdbool.h>
 #include <stdint.h>
-#include <stddef.h>
+#include "mysofa_export.h"
 
 #define MYSOFA_DEFAULT_NEIGH_STEP_ANGLE 0.5f
 #define MYSOFA_DEFAULT_NEIGH_STEP_RADIUS 0.01f
@@ -55,15 +55,15 @@
 struct MYSOFA_HRTF {
 
   /* Dimensions defined in AES69
- M Number of measurements; must be integer greater than zero.
- R Number of receivers; must be integer greater than zero.
- E Number of emitters; must be integer greater than zero.
- N Number of data samples describing one measurement; must be integer greater
- than zero. S Number of characters in a string; must be integer greater than
- zero. I 1 Singleton dimension, defines a scalar value. C 3 Coordinate
- triplet, always three; the coordinate type defines the meaning of this
- dimension.
- */
+   M Number of measurements; must be integer greater than zero.
+   R Number of receivers; must be integer greater than zero.
+   E Number of emitters; must be integer greater than zero.
+   N Number of data samples describing one measurement; must be integer greater
+   than zero. S Number of characters in a string; must be integer greater than
+   zero. I 1 Singleton dimension, defines a scalar value. C 3 Coordinate
+   triplet, always three; the coordinate type defines the meaning of this
+   dimension.
+   */
   unsigned I, C, R, E, N, M;
 
   struct MYSOFA_ARRAY ListenerPosition;
@@ -127,44 +127,44 @@
   MYSOFA_ONLY_SOURCES_WITH_MC_SUPPORTED
 };
 
-struct MYSOFA_HRTF *mysofa_load(const char *filename, int *err);
-struct MYSOFA_HRTF *mysofa_load_data(const char *data, size_t size, int *err);
+MYSOFA_EXPORT struct MYSOFA_HRTF *mysofa_load(const char *filename, int *err);
 
-int mysofa_check(struct MYSOFA_HRTF *hrtf);
-char *mysofa_getAttribute(struct MYSOFA_ATTRIBUTE *attr, char *name);
-void mysofa_tospherical(struct MYSOFA_HRTF *hrtf);
-void mysofa_tocartesian(struct MYSOFA_HRTF *hrtf);
-void mysofa_free(struct MYSOFA_HRTF *hrtf);
-
-struct MYSOFA_LOOKUP *mysofa_lookup_init(struct MYSOFA_HRTF *hrtf);
-int mysofa_lookup(struct MYSOFA_LOOKUP *lookup, float *coordinate);
-void mysofa_lookup_free(struct MYSOFA_LOOKUP *lookup);
+MYSOFA_EXPORT int mysofa_check(struct MYSOFA_HRTF *hrtf);
+MYSOFA_EXPORT void mysofa_tospherical(struct MYSOFA_HRTF *hrtf);
+MYSOFA_EXPORT void mysofa_tocartesian(struct MYSOFA_HRTF *hrtf);
+MYSOFA_EXPORT void mysofa_free(struct MYSOFA_HRTF *hrtf);
+
+MYSOFA_EXPORT struct MYSOFA_LOOKUP *mysofa_lookup_init(struct MYSOFA_HRTF *hrtf);
+MYSOFA_EXPORT int mysofa_lookup(struct MYSOFA_LOOKUP *lookup, float *coordinate);
+MYSOFA_EXPORT void mysofa_lookup_free(struct MYSOFA_LOOKUP *lookup);
 
-struct MYSOFA_NEIGHBORHOOD *
+MYSOFA_EXPORT struct MYSOFA_NEIGHBORHOOD *
 mysofa_neighborhood_init(struct MYSOFA_HRTF *hrtf,
                          struct MYSOFA_LOOKUP *lookup);
-struct MYSOFA_NEIGHBORHOOD *mysofa_neighborhood_init_withstepdefine(
+MYSOFA_EXPORT struct MYSOFA_NEIGHBORHOOD *mysofa_neighborhood_init_withstepdefine(
     struct MYSOFA_HRTF *hrtf, struct MYSOFA_LOOKUP *lookup,
     float neighbor_angle_step, float neighbor_radius_step);
-int *mysofa_neighborhood(struct MYSOFA_NEIGHBORHOOD *neighborhood, int pos);
-void mysofa_neighborhood_free(struct MYSOFA_NEIGHBORHOOD *neighborhood);
+MYSOFA_EXPORT int *mysofa_neighborhood(struct MYSOFA_NEIGHBORHOOD *neighborhood, int pos);
+MYSOFA_EXPORT void mysofa_neighborhood_free(struct MYSOFA_NEIGHBORHOOD *neighborhood);
 
-float *mysofa_interpolate(struct MYSOFA_HRTF *hrtf, float *cordinate,
+MYSOFA_EXPORT float *mysofa_interpolate(struct MYSOFA_HRTF *hrtf, float *cordinate,
                           int nearest, int *neighborhood, float *fir,
                           float *delays);
 
-int mysofa_resample(struct MYSOFA_HRTF *hrtf, float samplerate);
-float mysofa_loudness(struct MYSOFA_HRTF *hrtf);
-int mysofa_minphase(struct MYSOFA_HRTF *hrtf, float threshold);
+MYSOFA_EXPORT int mysofa_resample(struct MYSOFA_HRTF *hrtf, float samplerate);
+MYSOFA_EXPORT float mysofa_loudness(struct MYSOFA_HRTF *hrtf);
+MYSOFA_EXPORT int mysofa_minphase(struct MYSOFA_HRTF *hrtf, float threshold);
 
-struct MYSOFA_EASY *mysofa_cache_lookup(const char *filename, float samplerate);
-struct MYSOFA_EASY *mysofa_cache_store(struct MYSOFA_EASY *,
+MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_cache_lookup(const char *filename, float samplerate);
+MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_cache_store(struct MYSOFA_EASY *,
                                        const char *filename, float samplerate);
-void mysofa_cache_release(struct MYSOFA_EASY *);
-void mysofa_cache_release_all(void);
+MYSOFA_EXPORT void mysofa_cache_release(struct MYSOFA_EASY *);
+MYSOFA_EXPORT void mysofa_cache_release_all(void);
+
+MYSOFA_EXPORT char* mysofa_getAttribute(struct MYSOFA_ATTRIBUTE* attr, char* name);
+MYSOFA_EXPORT void mysofa_c2s(float values[3]);
+MYSOFA_EXPORT void mysofa_s2c(float values[3]);
 
-void mysofa_c2s(float values[3]);
-void mysofa_s2c(float values[3]);
 
 struct MYSOFA_EASY {
   struct MYSOFA_HRTF *hrtf;
@@ -173,38 +173,29 @@
   float *fir;
 };
 
-struct MYSOFA_EASY *mysofa_open(const char *filename, float samplerate,
+MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_open(const char *filename, float samplerate,
                                 int *filterlength, int *err);
-struct MYSOFA_EASY *mysofa_open_no_norm(const char *filename, float samplerate,
+MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_open_no_norm(const char *filename, float samplerate,
                                         int *filterlength, int *err);
-struct MYSOFA_EASY *mysofa_open_advanced(const char *filename, float samplerate,
+MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_open_advanced(const char *filename, float samplerate,
                                          int *filterlength, int *err, bool norm,
                                          float neighbor_angle_step,
                                          float neighbor_radius_step);
-struct MYSOFA_EASY *mysofa_open_data(const char *data, long size,
-                                     float samplerate, int *filterlength,
-                                     int *err);
-struct MYSOFA_EASY *mysofa_open_data_no_norm(const char *data, long size,
-                                             float samplerate,
-                                             int *filterlength, int *err);
-struct MYSOFA_EASY *mysofa_open_data_advanced(
-    const char *data, long size, float samplerate, int *filterlength, int *err,
-    bool norm, float neighbor_angle_step, float neighbor_radius_step);
-struct MYSOFA_EASY *mysofa_open_cached(const char *filename, float samplerate,
+MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_open_cached(const char *filename, float samplerate,
                                        int *filterlength, int *err);
-void mysofa_getfilter_short(struct MYSOFA_EASY *easy, float x, float y, float z,
+MYSOFA_EXPORT void mysofa_getfilter_short(struct MYSOFA_EASY *easy, float x, float y, float z,
                             short *IRleft, short *IRright, int *delayLeft,
                             int *delayRight);
-void mysofa_getfilter_float(struct MYSOFA_EASY *easy, float x, float y, float z,
+MYSOFA_EXPORT void mysofa_getfilter_float(struct MYSOFA_EASY *easy, float x, float y, float z,
                             float *IRleft, float *IRright, float *delayLeft,
                             float *delayRight);
-void mysofa_getfilter_float_nointerp(struct MYSOFA_EASY *easy, float x, float y,
+MYSOFA_EXPORT void mysofa_getfilter_float_nointerp(struct MYSOFA_EASY *easy, float x, float y,
                                      float z, float *IRleft, float *IRright,
                                      float *delayLeft, float *delayRight);
-void mysofa_close(struct MYSOFA_EASY *easy);
-void mysofa_close_cached(struct MYSOFA_EASY *easy);
+MYSOFA_EXPORT void mysofa_close(struct MYSOFA_EASY *easy);
+MYSOFA_EXPORT void mysofa_close_cached(struct MYSOFA_EASY *easy);
 
-void mysofa_getversion(int *major, int *minor, int *patch);
+MYSOFA_EXPORT void mysofa_getversion(int *major, int *minor, int *patch);
 
 #ifdef __cplusplus
 }
diff -ur libmysofa.orig/src/hrtf/neighbors.c libmysofa/src/hrtf/neighbors.c
--- libmysofa.orig/src/hrtf/neighbors.c	2023-02-03 11:03:54.965008894 +0100
+++ libmysofa/src/hrtf/neighbors.c	2023-02-01 14:20:31.902431210 +0100
@@ -13,7 +13,7 @@
 #include <stdlib.h>
 #include <string.h>
 
-MYSOFA_EXPORT struct MYSOFA_NEIGHBORHOOD *
+struct MYSOFA_NEIGHBORHOOD *
 mysofa_neighborhood_init(struct MYSOFA_HRTF *hrtf,
                          struct MYSOFA_LOOKUP *lookup) {
   return mysofa_neighborhood_init_withstepdefine(
@@ -21,7 +21,7 @@
       MYSOFA_DEFAULT_NEIGH_STEP_RADIUS);
 }
 
-MYSOFA_EXPORT struct MYSOFA_NEIGHBORHOOD *
+struct MYSOFA_NEIGHBORHOOD *
 mysofa_neighborhood_init_withstepdefine(struct MYSOFA_HRTF *hrtf,
                                         struct MYSOFA_LOOKUP *lookup,
                                         float angleStep, float radiusStep) {
@@ -151,14 +151,14 @@
   return neighbor;
 }
 
-MYSOFA_EXPORT int *mysofa_neighborhood(struct MYSOFA_NEIGHBORHOOD *neighborhood,
+int *mysofa_neighborhood(struct MYSOFA_NEIGHBORHOOD *neighborhood,
                                        int index) {
   if (index < 0 || index >= neighborhood->elements)
     return NULL;
   return neighborhood->index + index * 6;
 }
 
-MYSOFA_EXPORT void
+void
 mysofa_neighborhood_free(struct MYSOFA_NEIGHBORHOOD *neighborhood) {
   if (neighborhood) {
     free(neighborhood->index);
diff -ur libmysofa.orig/src/hrtf/reader.c libmysofa/src/hrtf/reader.c
--- libmysofa.orig/src/hrtf/reader.c	2023-02-03 11:03:54.965008894 +0100
+++ libmysofa/src/hrtf/reader.c	2023-02-01 14:20:31.902431210 +0100
@@ -11,7 +11,7 @@
 #include <stdlib.h>
 #include <string.h>
 
-#include "config.h"
+#include "../config.h"
 #include "../hdf/reader.h"
 #include "mysofa.h"
 #include "mysofa_export.h"
@@ -23,75 +23,16 @@
   return address > 0 && address < reader->superblock.end_of_file_address;
 }
 
-int mysofa_read(struct READER *reader, void *buf, size_t n) {
-  if (reader->fhd)
-    return fread(buf, 1, n, reader->fhd);
-  else {
-    if (reader->memory_pos + n > reader->memory_len) {
-      n = reader->memory_len - reader->memory_pos;
-    }
-
-    memcpy(buf, reader->memory + reader->memory_pos, n);
-    reader->memory_pos += n;
-
-    return n;
-  }
-}
-
-int mysofa_seek(struct READER *reader, long offset, int whence) {
-  if (reader->fhd)
-    return fseek(reader->fhd, offset, whence);
-  else {
-    switch (whence) {
-    case SEEK_SET:
-      reader->memory_pos = offset;
-      break;
-    case SEEK_CUR:
-      reader->memory_pos += offset;
-      break;
-    case SEEK_END:
-      reader->memory_pos = reader->memory_len + offset;
-      break;
-    default:
-      errno = EINVAL;
-      return -1;
-    }
-
-    return 0;
-  }
-}
-
-long mysofa_tell(struct READER *reader) {
-  if (reader->fhd)
-    return ftell(reader->fhd);
-  else
-    return reader->memory_pos;
-}
-
-int mysofa_getc(struct READER *reader) {
-  if (reader->fhd)
-    return fgetc(reader->fhd);
-  else {
-    if (reader->memory_pos == reader->memory_len) {
-      return -1;
-    } else {
-      unsigned char ch = reader->memory[reader->memory_pos];
-      reader->memory_pos++;
-      return (int)ch;
-    }
-  }
-}
-
 /* little endian */
 uint64_t readValue(struct READER *reader, int size) {
   int i, c;
   uint64_t value;
-  c = mysofa_getc(reader);
+  c = fgetc(reader->fhd);
   if (c < 0)
     return 0xffffffffffffffffLL;
   value = (uint8_t)c;
   for (i = 1; i < size; i++) {
-    c = mysofa_getc(reader);
+    c = fgetc(reader->fhd);
     if (c < 0)
       return 0xffffffffffffffffLL;
     value |= ((uint64_t)c) << (i * 8);
@@ -99,7 +40,7 @@
   return value;
 }
 
-static int mysofa_strcmp(char *s1, char *s2) {
+static int mystrcmp(char *s1, char *s2) {
   if (s1 == NULL && s2 == NULL)
     return 0;
   if (s1 == NULL)
@@ -112,8 +53,7 @@
 static int checkAttribute(struct MYSOFA_ATTRIBUTE *attribute, char *name,
                           char *value) {
   while (attribute) {
-    if (!mysofa_strcmp(attribute->name, name) &&
-        !mysofa_strcmp(attribute->value, value))
+    if (!mystrcmp(attribute->name, name) && !mystrcmp(attribute->value, value))
       return MYSOFA_OK;
     attribute = attribute->next;
   }
@@ -341,25 +281,9 @@
   return NULL;
 }
 
-struct MYSOFA_HRTF *load(struct READER *reader, int *err) {
-  struct MYSOFA_HRTF *hrtf = NULL;
-  reader->gcol = NULL;
-  reader->all = NULL;
-  reader->recursive_counter = 0;
-
-  *err = superblockRead(reader, &reader->superblock);
-  if (!*err) {
-    hrtf = getHrtf(reader, err);
-  }
-
-  superblockFree(reader, &reader->superblock);
-  gcolFree(reader->gcol);
-  return hrtf;
-}
-
-MYSOFA_EXPORT struct MYSOFA_HRTF *mysofa_load(const char *filename, int *err) {
-
+struct MYSOFA_HRTF *mysofa_load(const char *filename, int *err) {
   struct READER reader;
+  struct MYSOFA_HRTF *hrtf = NULL;
 
   if (filename == NULL)
     filename = CMAKE_INSTALL_PREFIX "/share/libmysofa/default.sofa";
@@ -374,25 +298,25 @@
     *err = errno;
     return NULL;
   }
-  struct MYSOFA_HRTF *hrtf = load(&reader, err);
-  fclose(reader.fhd);
-  return hrtf;
-}
+  reader.gcol = NULL;
+  reader.all = NULL;
+  reader.recursive_counter = 0;
 
-MYSOFA_EXPORT struct MYSOFA_HRTF *
-mysofa_load_data(const char *data, const size_t size, int *err) {
-  struct READER reader;
+  *err = superblockRead(&reader, &reader.superblock);
 
-  reader.memory = data;
-  reader.memory_pos = 0L;
-  reader.memory_len = size;
-  reader.fhd = NULL;
+  if (!*err) {
+    hrtf = getHrtf(&reader, err);
+  }
+
+  superblockFree(&reader, &reader.superblock);
+  gcolFree(reader.gcol);
+  if (strcmp(filename, "-"))
+    fclose(reader.fhd);
 
-  struct MYSOFA_HRTF *hrtf = load(&reader, err);
   return hrtf;
 }
 
-MYSOFA_EXPORT void mysofa_free(struct MYSOFA_HRTF *hrtf) {
+void mysofa_free(struct MYSOFA_HRTF *hrtf) {
   if (!hrtf)
     return;
 
@@ -425,7 +349,7 @@
   free(hrtf);
 }
 
-MYSOFA_EXPORT void mysofa_getversion(int *major, int *minor, int *patch) {
+void mysofa_getversion(int *major, int *minor, int *patch) {
   *major = CPACK_PACKAGE_VERSION_MAJOR;
   *minor = CPACK_PACKAGE_VERSION_MINOR;
   *patch = CPACK_PACKAGE_VERSION_PATCH;
diff -ur libmysofa.orig/src/hrtf/spherical.c libmysofa/src/hrtf/spherical.c
--- libmysofa.orig/src/hrtf/spherical.c	2023-02-03 11:03:54.965008894 +0100
+++ libmysofa/src/hrtf/spherical.c	2023-02-01 14:20:31.902431210 +0100
@@ -14,7 +14,7 @@
   convertCartesianToSpherical(array->values, array->elements);
 }
 
-MYSOFA_EXPORT void mysofa_tospherical(struct MYSOFA_HRTF *hrtf) {
+void mysofa_tospherical(struct MYSOFA_HRTF *hrtf) {
   convertArray(&hrtf->ListenerView);
   convertArray(&hrtf->ListenerUp);
   convertArray(&hrtf->ListenerPosition);
@@ -32,7 +32,7 @@
   convertSphericalToCartesian(array->values, array->elements);
 }
 
-MYSOFA_EXPORT void mysofa_tocartesian(struct MYSOFA_HRTF *hrtf) {
+void mysofa_tocartesian(struct MYSOFA_HRTF *hrtf) {
   convertArray2(&hrtf->ListenerView);
   convertArray2(&hrtf->ListenerUp);
   convertArray2(&hrtf->ListenerPosition);
diff -ur libmysofa.orig/src/hrtf/tools.c libmysofa/src/hrtf/tools.c
--- libmysofa.orig/src/hrtf/tools.c	2023-02-03 11:03:54.965008894 +0100
+++ libmysofa/src/hrtf/tools.c	2023-02-01 16:52:33.401320770 +0100
@@ -9,12 +9,11 @@
 #endif // !_USE_MATH_DEFINES
 #include "tools.h"
 #include "mysofa.h"
-#include "mysofa_export.h"
 #include <math.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-
+ 
 char *mysofa_strdup(const char *str) {
   size_t size = strlen(str) + 1;
   char *copy = malloc(size);
@@ -47,8 +46,7 @@
   return 0;
 }
 
-MYSOFA_EXPORT
-char *mysofa_getAttribute(struct MYSOFA_ATTRIBUTE *attr, char *name) {
+char* mysofa_getAttribute(struct MYSOFA_ATTRIBUTE* attr, char* name) {
   while (attr) {
     if (attr->name && !strcmp(name, attr->name)) {
       return attr->value;
@@ -58,7 +56,8 @@
   return NULL;
 }
 
-MYSOFA_EXPORT void mysofa_c2s(float values[3]) {
+
+void mysofa_c2s(float values[3]) {
   float x, y, z, r, theta, phi;
   x = values[0];
   y = values[1];
@@ -73,7 +72,7 @@
   values[2] = r;
 }
 
-MYSOFA_EXPORT void mysofa_s2c(float values[3]) {
+void mysofa_s2c(float values[3]) {
   float x, r, theta, phi;
   phi = values[0] * (M_PI / 180);
   theta = values[1] * (M_PI / 180);
diff -ur libmysofa.orig/src/tests/external.c libmysofa/src/tests/external.c
--- libmysofa.orig/src/tests/external.c	2023-02-03 11:03:54.965008894 +0100
+++ libmysofa/src/tests/external.c	2023-02-01 14:20:31.902431210 +0100
@@ -24,8 +24,6 @@
   /* add the tests to the suite */
   /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */
   if ((NULL == CU_add_test(pSuite, "test of mysofa_check", test_check)) ||
-      (NULL ==
-       CU_add_test(pSuite, "test of mysofa_check_data", test_check_data)) ||
       (NULL == CU_add_test(pSuite, "test of mysofa_lookup", test_lookup)) ||
       (NULL ==
        CU_add_test(pSuite, "test of mysofa_neighbors", test_neighbors)) ||
@@ -37,8 +35,7 @@
       (NULL == CU_add_test(pSuite, "test of mysofa_cache", test_cache)) ||
       (NULL ==
        CU_add_test(pSuite, "test of mysofa_easy open", test_easy_open)) ||
-      (NULL ==
-       CU_add_test(pSuite, "test of mysofa_easy nonorm", test_easy_nonorm)) ||
+      (NULL == CU_add_test(pSuite, "test of mysofa_easy nonorm", test_easy_nonorm)) ||
       (NULL == CU_add_test(pSuite, "test of mysofa_easy", test_easy)) ||
       (NULL == CU_add_test(pSuite, "test of user defined variables",
                            test_user_defined_variable))) {
diff -ur libmysofa.orig/src/tests/tests.h libmysofa/src/tests/tests.h
--- libmysofa.orig/src/tests/tests.h	2023-02-03 11:03:54.965008894 +0100
+++ libmysofa/src/tests/tests.h	2023-02-01 14:20:31.902431210 +0100
@@ -17,8 +17,6 @@
 
 void test_check();
 
-void test_check_data();
-
 void test_lookup();
 
 void test_neighbors();
